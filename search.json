[{"path":"https://jhelvy.github.io/cbcTools/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 John Paul Helveston Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"choice-simulation-approaches","dir":"Articles","previous_headings":"","what":"Choice Simulation Approaches","title":"Simulating Choices","text":"cbc_choices() supports two simulation approaches: Random simulation: alternative equal probability chosen Utility-based simulation: Choice probabilities based multinomial logit model specified priors","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"random-choices","dir":"Articles","previous_headings":"Choice Simulation Approaches","what":"Random Choices","title":"Simulating Choices","text":"Without priors, choices simulated randomly equal probabilities: Random simulation useful : Quick testing design structure Conservative power analysis (worst-case scenario) Baseline comparisons","code":"# Random choice simulation (default) choices_random <- cbc_choices(design)  head(choices_random) #> CBC Choice Data #> =============== #> Observations: 3 choice tasks #> Alternatives per task: 2 #> Total choices made: 3 #>  #> Simulation method: random #> Priors: None (random choices) #> Simulated at: 2025-07-08 11:17:23 #>  #> Choice rates by alternative: #>   Alt 1: 33.3% (1 choices) #>   Alt 2: 66.7% (2 choices) #>  #> First few rows: #>   profileID respID qID altID obsID price typeGala typeHoneycrisp #> 1        31      1   1     1     1   1.0        0              0 #> 2        15      1   1     2     1   3.0        0              1 #> 3        14      1   2     1     2   2.5        0              1 #> 4         3      1   2     2     2   2.0        0              0 #> 5        42      1   3     1     3   1.5        0              1 #> 6        43      1   3     2     3   2.0        0              1 #>   freshnessAverage freshnessExcellent choice #> 1                0                  1      0 #> 2                0                  0      1 #> 3                0                  0      0 #> 4                0                  0      1 #> 5                0                  1      1 #> 6                0                  1      0  # Check choice distribution table(choices_random$choice, choices_random$altID) #>     #>       1   2 #>   0 294 306 #>   1 306 294"},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"utility-based-choices","dir":"Articles","previous_headings":"Choice Simulation Approaches","what":"Utility-Based Choices","title":"Simulating Choices","text":"priors, choices follow realistic utility-based patterns:","code":"# Create priors for utility-based simulation priors <- cbc_priors(   profiles = profiles,   price = -0.25, # Negative preference for higher prices   type = c(0.5, 1), # Gala and Honeycrisp preferred over Fuji   freshness = c(0.6, 1.2) # Average and Excellent preferred over Poor )  # Utility-based choice simulation choices_utility <- cbc_choices(design, priors = priors)  head(choices_utility) #> CBC Choice Data #> =============== #> Observations: 3 choice tasks #> Alternatives per task: 2 #> Total choices made: 3 #>  #> Simulation method: utility_based #> Priors: Used for utility-based simulation #> Simulated at: 2025-07-08 11:17:23 #>  #> Choice rates by alternative: #>   Alt 1: 66.7% (2 choices) #>   Alt 2: 33.3% (1 choices) #>  #> First few rows: #>   profileID respID qID altID obsID price typeGala typeHoneycrisp #> 1        31      1   1     1     1   1.0        0              0 #> 2        15      1   1     2     1   3.0        0              1 #> 3        14      1   2     1     2   2.5        0              1 #> 4         3      1   2     2     2   2.0        0              0 #> 5        42      1   3     1     3   1.5        0              1 #> 6        43      1   3     2     3   2.0        0              1 #>   freshnessAverage freshnessExcellent choice #> 1                0                  1      1 #> 2                0                  0      0 #> 3                0                  0      0 #> 4                0                  0      1 #> 5                0                  1      1 #> 6                0                  1      0"},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"choice-data-format","dir":"Articles","previous_headings":"Choice Simulation Approaches","what":"Choice Data Format","title":"Simulating Choices","text":"simulated choice data includes design columns plus choice column:","code":"head(choices_utility) #> CBC Choice Data #> =============== #> Observations: 3 choice tasks #> Alternatives per task: 2 #> Total choices made: 3 #>  #> Simulation method: utility_based #> Priors: Used for utility-based simulation #> Simulated at: 2025-07-08 11:17:23 #>  #> Choice rates by alternative: #>   Alt 1: 66.7% (2 choices) #>   Alt 2: 33.3% (1 choices) #>  #> First few rows: #>   profileID respID qID altID obsID price typeGala typeHoneycrisp #> 1        31      1   1     1     1   1.0        0              0 #> 2        15      1   1     2     1   3.0        0              1 #> 3        14      1   2     1     2   2.5        0              1 #> 4         3      1   2     2     2   2.0        0              0 #> 5        42      1   3     1     3   1.5        0              1 #> 6        43      1   3     2     3   2.0        0              1 #>   freshnessAverage freshnessExcellent choice #> 1                0                  1      1 #> 2                0                  0      0 #> 3                0                  0      0 #> 4                0                  0      1 #> 5                0                  1      1 #> 6                0                  1      0"},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"designs-with-no-choice","dir":"Articles","previous_headings":"Advanced Simulation Options","what":"Designs with No-Choice","title":"Simulating Choices","text":"designs -choice options, specify -choice priors:","code":"# Create design with no-choice option design_nochoice <- cbc_design(   profiles = profiles,   n_alts = 2,   n_q = 6,   n_resp = 100,   no_choice = TRUE,   method = \"random\" )  # Create priors including no-choice utility priors_nochoice <- cbc_priors(   profiles = profiles,   price = -0.25,   type = c(0.5, 1.0),   freshness = c(0.6, 1.2),   no_choice = -0.5 # Negative = no-choice less attractive )  # Simulate choices choices_nochoice <- cbc_choices(   design_nochoice,   priors = priors_nochoice )  # Examine no-choice rates nochoice_rate <- mean(choices_nochoice$choice[choices_nochoice$no_choice == 1]) cat(\"No-choice selection rate:\", round(nochoice_rate * 100, 1), \"%\\n\") #> No-choice selection rate: 13.3 %"},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"random-parameters-mixed-logit","dir":"Articles","previous_headings":"Advanced Simulation Options","what":"Random Parameters (Mixed Logit)","title":"Simulating Choices","text":"Simulate heterogeneous preferences using random parameters:","code":"# Create priors with random parameters priors_random <- cbc_priors(   profiles = profiles,   price = rand_spec(dist = \"n\", mean = -0.1, sd = 0.05),   type = rand_spec(dist = \"n\", mean = c(0.1, 0.2), sd = c(0.05, 0.1)),   freshness = c(0.1, 0.2), # Keep some parameters fixed   n_draws = 100 )  # Simulate choices with preference heterogeneity choices_mixed <- cbc_choices(design, priors = priors_random)"},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"interaction-effects","dir":"Articles","previous_headings":"Advanced Simulation Options","what":"Interaction Effects","title":"Simulating Choices","text":"Include interaction effects choice simulation:","code":"# Create priors with interactions priors_interactions <- cbc_priors(   profiles = profiles,   price = -0.1,   type = c(\"Fuji\" = 0.5, \"Gala\" = 1),   freshness = c(\"Average\" = 0.6, \"Excellent\" = 1.2),   interactions = list(     # Price sensitivity varies by apple type     int_spec(       between = c(\"price\", \"type\"),       with_level = \"Fuji\",       value = 0.5     ),     int_spec(       between = c(\"price\", \"type\"),       with_level = \"Gala\",       value = 0.2     )   ) )  # Simulate choices with interaction effects choices_interactions <- cbc_choices(   design,   priors = priors_interactions )"},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"overall-choice-frequencies","dir":"Articles","previous_headings":"Validating Choice Patterns","what":"Overall Choice Frequencies","title":"Simulating Choices","text":"Based priors used, expect: Lower prices preferred (negative price coefficient) Honeycrisp > Gala > Fuji (type coefficients: 0.2 > 0.1 > 0) Excellent > Average > Poor (freshness coefficients: 0.2 > 0.1 > 0) Examine aggregate choice patterns validate simulation:","code":"# Decode the choice data first to get categorical variables choices_decoded <- cbc_decode(choices_utility)  # Aggregate attribute choices across all respondents choices <- choices_decoded  # Price choices price_choices <- aggregate(choice ~ price, data = choices, sum) price_choices$prop <- price_choices$choice / sum(price_choices$choice) print(price_choices) #>   price choice      prop #> 1   1.0    123 0.2050000 #> 2   1.5    119 0.1983333 #> 3   2.0    121 0.2016667 #> 4   2.5    107 0.1783333 #> 5   3.0    130 0.2166667  # Type choices type_choices <- aggregate(choice ~ type, data = choices, sum) type_choices$prop <- type_choices$choice / sum(type_choices$choice) print(type_choices) #>         type choice  prop #> 1       Fuji    171 0.285 #> 2       Gala    213 0.355 #> 3 Honeycrisp    216 0.360  # Freshness choices freshness_choices <- aggregate(choice ~ freshness, data = choices, sum) freshness_choices$prop <- freshness_choices$choice /   sum(freshness_choices$choice) print(freshness_choices) #>   freshness choice      prop #> 1      Poor    145 0.2416667 #> 2   Average    210 0.3500000 #> 3 Excellent    245 0.4083333"},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"respondent-heterogeneity","dir":"Articles","previous_headings":"Validating Choice Patterns","what":"Respondent Heterogeneity","title":"Simulating Choices","text":"random parameter models, examine variation across respondents:","code":"# Create dataset with only chosen alternatives chosen_alts <- choices_mixed[choices_mixed$choice == 1, ]  # Mean attribute levels chosen by each respondent resp_means <- aggregate(   cbind(     price,     typeGala,     typeHoneycrisp,     freshnessAverage,     freshnessExcellent   ) ~     respID,   data = chosen_alts,   mean )  # Look at variation across respondents cat(\"Price variation across respondents:\\n\") #> Price variation across respondents: cat(\"Mean:\", round(mean(resp_means$price), 2), \"\\n\") #> Mean: 2.01 cat(\"SD:\", round(sd(resp_means$price), 2), \"\\n\") #> SD: 0.28  cat(\"\\nHoneycrisp choice rate variation:\\n\") #>  #> Honeycrisp choice rate variation: cat(\"Mean:\", round(mean(resp_means$typeHoneycrisp), 2), \"\\n\") #> Mean: 0.32 cat(\"SD:\", round(sd(resp_means$typeHoneycrisp), 2), \"\\n\") #> SD: 0.2"},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"using-consistent-priors","dir":"Articles","previous_headings":"Design Consistency","what":"Using Consistent Priors","title":"Simulating Choices","text":"D-optimal designs created priors, use priors choice simulation:","code":"# Create D-optimal design with priors design_optimal <- cbc_design(   profiles = profiles,   n_alts = 2,   n_q = 6,   n_resp = 100,   priors = priors,   method = \"stochastic\" )  # Use SAME priors for choice simulation choices_consistent <- cbc_choices(   design_optimal,   priors = priors )"},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"prior-consistency-warnings","dir":"Articles","previous_headings":"Design Consistency","what":"Prior Consistency Warnings","title":"Simulating Choices","text":"cbcTools warns different priors used:","code":"# Create different priors different_priors <- cbc_priors(   profiles = profiles,   price = -0.2, # Different from design optimization   type = c(0.2, 0.4),   freshness = c(0.2, 0.4) )  # This will generate a warning about inconsistent priors choices_inconsistent <- cbc_choices(   design_optimal,   priors = different_priors )"},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"prior-specification","dir":"Articles","previous_headings":"Best Practices","what":"Prior Specification","title":"Simulating Choices","text":"Use realistic priors: Base literature, pilot studies, expert judgment Match design priors: Use priors design optimization choice simulation Test multiple scenarios: Simulate optimistic conservative assumptions Include heterogeneity: Use random parameters appropriate","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"validation-steps","dir":"Articles","previous_headings":"Best Practices","what":"Validation Steps","title":"Simulating Choices","text":"Check choice counts: Verify one choice per question Examine patterns: Ensure choices align prior expectations Test extremes: Simulate strong/weak preferences Compare methods: Test different simulation approaches","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/choices.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Simulating Choices","text":"simulating choices: Conduct power analysis using cbc_power() determine sample size requirements Compare designs simulating choices different design methods Validate assumptions checking simulated patterns match expectations Refine priors based simulation results data collection details power analysis, see Power Analysis vignette.","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/d_error.html","id":"what-is-d-error","dir":"Articles","previous_headings":"","what":"What is D-error?","title":"Computing D-error in Choice Experiments","text":"D-error measure good bad design extracting information respondents choice experiment. design low D-error better design high D-error, provided designs experiment. Comparing D-error designs different experiments meaningless. generating designs using D-optimal methods cbc_design(), several methods (\"stochastic\", \"modfed\", \"cea\") use algorithm minimizes D-error find efficient experimental designs. specific type D-error computed depends prior assumptions provide. Note: “D-optimal” design necessarily best design experiment. designs optimize information “main effects” interest, expence information interactions. feel interactions may important, consider using different design method consider including interactions priors.","code":""},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/articles/d_error.html","id":"prior-parameter-assumptions","dir":"Articles","previous_headings":"Types of D-error","what":"Prior Parameter Assumptions","title":"Computing D-error in Choice Experiments","text":"computing D-error, prior assumption respondent parameters needs made: D0D_0-error assumes parameters zero — .e., respondents preference attribute levels DpD_p-error assumes respondent parameters equal fixed parameter vector DBD_B-error assumes respondent parameters distributed according probability distribution (typically multivariate normal)","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/d_error.html","id":"how-cbctools-chooses-d-error-type","dir":"Articles","previous_headings":"Types of D-error","what":"How cbcTools Chooses D-error Type","title":"Computing D-error in Choice Experiments","text":"cbc_design() D-optimal methods (\"stochastic\", \"modfed\", \"cea\"), type D-error minimized depends prior specifications: priors provided (priors = NULL) → Uses D0D_0-error Fixed parameters (using cbc_priors() fixed values) → Uses DpD_p-error Random parameters (using cbc_priors() rand_spec()) → Uses DBD_B-error","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/d_error.html","id":"working-example","dir":"Articles","previous_headings":"","what":"Working Example","title":"Computing D-error in Choice Experiments","text":"Let’s work mathematical steps D-error computation using example literature.","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/d_error.html","id":"the-design","dir":"Articles","previous_headings":"Working Example","what":"The Design","title":"Computing D-error in Choice Experiments","text":"Consider simple 3-attribute, 2-alternative choice experiment:","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/d_error.html","id":"step-1-encode-the-design","dir":"Articles","previous_headings":"Working Example","what":"Step 1: Encode the Design","title":"Computing D-error in Choice Experiments","text":"first step encode design using dummy coding. 2-level attribute, create one dummy variable (comparing level 2 vs. level 1 reference). gives us: Question 1: X1=(010101)X_1 = \\begin{pmatrix} 0 & 1 & 0 \\\\ 1 & 0 & 1 \\end{pmatrix} Question 2: X2=(011100)X_2 = \\begin{pmatrix} 0 & 1 & 1 \\\\ 1 & 0 & 0 \\end{pmatrix} Question 3: X3=(110001)X_3 = \\begin{pmatrix} 1 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/d_error.html","id":"computing-d_p-error-fixed-parameters","dir":"Articles","previous_headings":"","what":"Computing DpD_p-error (Fixed Parameters)","title":"Computing D-error in Choice Experiments","text":"DpD_p-error, assume specific parameter values: 𝛃=[0.5,−0.5,0.8]\\boldsymbol{\\beta} = [0.5, -0.5, 0.8].","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/d_error.html","id":"step-2-compute-choice-probabilities","dir":"Articles","previous_headings":"Computing DpD_p-error (Fixed Parameters)","what":"Step 2: Compute Choice Probabilities","title":"Computing D-error in Choice Experiments","text":"Using multinomial logit formula: Piq=exp(Xiq𝛃)∑j=1Jexp(Xjq𝛃)P_{iq} = \\frac{\\exp(X_{iq} \\boldsymbol{\\beta})}{\\sum_{j=1}^{J} \\exp(X_{jq} \\boldsymbol{\\beta})} Question 1: - Utility Alt1: U1=0×0.5+1×(−0.5)+0×0.8=−0.5U_1 = 0 \\times 0.5 + 1 \\times (-0.5) + 0 \\times 0.8 = -0.5 - Utility Alt2: U2=1×0.5+0×(−0.5)+1×0.8=1.3U_2 = 1 \\times 0.5 + 0 \\times (-0.5) + 1 \\times 0.8 = 1.3 - P11=e−0.5e−0.5+e1.3=0.143P_{11} = \\frac{e^{-0.5}}{e^{-0.5} + e^{1.3}} = 0.143 - P21=e1.3e−0.5+e1.3=0.857P_{21} = \\frac{e^{1.3}}{e^{-0.5} + e^{1.3}} = 0.857 Similar calculations Questions 2 3 give us choice probabilities alternative question.","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/d_error.html","id":"step-3-compute-fisher-information-matrix","dir":"Articles","previous_headings":"Computing DpD_p-error (Fixed Parameters)","what":"Step 3: Compute Fisher Information Matrix","title":"Computing D-error in Choice Experiments","text":"Fisher information matrix choice set uses formula: Iq=XqT(diag(𝐏𝐪)−𝐏𝐪𝐏𝐪T)XqI_q = X_q^T \\left( \\text{diag}(\\mathbf{P_q}) - \\mathbf{P_q} \\mathbf{P_q}^T \\right) X_q 𝐏𝐪\\mathbf{P_q} vector choice probabilities choice set qq, diag(𝐏𝐪)\\text{diag}(\\mathbf{P_q}) creates diagonal matrix vector. total information matrix : =∑q=1QIqI = \\sum_{q=1}^{Q} I_q","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/d_error.html","id":"step-4-compute-d_p-error","dir":"Articles","previous_headings":"Computing DpD_p-error (Fixed Parameters)","what":"Step 4: Compute DpD_p-error","title":"Computing D-error in Choice Experiments","text":"DpD_p-error calculated : Dp-error=(det())−1/KD_p\\text{-error} = (\\det())^{-1/K} K=3K = 3 number parameters.","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/d_error.html","id":"computing-d_0-error-no-priors","dir":"Articles","previous_headings":"","what":"Computing D0D_0-error (No Priors)","title":"Computing D-error in Choice Experiments","text":"D0D_0-error special case 𝛃=[0,0,0]\\boldsymbol{\\beta} = [0, 0, 0], making alternatives equally likely. parameters zero: - utilities = 0 - choice probabilities = 1J\\frac{1}{J} JJ number alternatives 2-alternative case: Piq=0.5P_{iq} = 0.5 alternatives. information matrix calculation follows formula, equal probabilities. simplifies calculation considerably since: diag(𝐏𝐪)−𝐏𝐪𝐏𝐪T=diag(0.5,0.5)−(0.250.250.250.25)=(0.25−0.25−0.250.25)\\text{diag}(\\mathbf{P_q}) - \\mathbf{P_q} \\mathbf{P_q}^T = \\text{diag}(0.5, 0.5) - \\begin{pmatrix} 0.25 & 0.25 \\\\ 0.25 & 0.25 \\end{pmatrix} = \\begin{pmatrix} 0.25 & -0.25 \\\\ -0.25 & 0.25 \\end{pmatrix}","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/d_error.html","id":"computing-d_b-error-random-parameters","dir":"Articles","previous_headings":"","what":"Computing DBD_B-error (Random Parameters)","title":"Computing D-error in Choice Experiments","text":"DBD_B-error assumes parameters follow probability distribution. example, assume: 𝛃∼N([0.5,−0.5,0.8],diag([0.52,0.52,0.52]))\\boldsymbol{\\beta} \\sim N\\left([0.5, -0.5, 0.8], \\text{diag}([0.5^2, 0.5^2, 0.5^2])\\right) computation involves: Draw parameter samples distribution (e.g., R=1000R = 1000 draws) Compute DpD_p-error parameter draw 𝛃(r)\\boldsymbol{\\beta}^{(r)} Average results get DBD_B-error DB-error=1R∑r=1RDp-error(𝛃(r))D_B\\text{-error} = \\frac{1}{R} \\sum_{r=1}^{R} D_p\\text{-error}(\\boldsymbol{\\beta}^{(r)}) DBD_B-error = mean DpD_p-errors = 1.90 Note: example used article inspired article displayr.com.","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"design-basics","dir":"Articles","previous_headings":"","what":"Design Basics","title":"Generating Designs","text":"cbc_design() function generates data frame encoded experiment design formatted one row per alternative. Choice questions defined sets rows obsID. Let’s start simple example (random design):","code":"design <- cbc_design(   profiles = profiles,   n_alts = 2, # Alternatives per question   n_q = 6, # Questions per respondent   n_resp = 100 # Number of respondents )  design #> Design method: random #> Structure: 100 respondents × 6 questions × 2 alternatives #> Profile usage: 45/45 (100.0%) #>  #> 💡 Use cbc_inspect() for a more detailed summary #>  #> First few rows of design: #>   profileID respID qID altID obsID price typeGala typeHoneycrisp #> 1        31      1   1     1     1   1.0        0              0 #> 2        15      1   1     2     1   3.0        0              1 #> 3        14      1   2     1     2   2.5        0              1 #> 4         3      1   2     2     2   2.0        0              0 #> 5        42      1   3     1     3   1.5        0              1 #> 6        43      1   3     2     3   2.0        0              1 #>   freshnessAverage freshnessExcellent #> 1                0                  1 #> 2                0                  0 #> 3                0                  0 #> 4                0                  0 #> 5                0                  1 #> 6                0                  1 #> ... and 1194 more rows"},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"understanding-the-design-structure","dir":"Articles","previous_headings":"Design Basics","what":"Understanding the Design Structure","title":"Generating Designs","text":"design data frame contains several types columns help organize experiment:","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"id-columns","dir":"Articles","previous_headings":"Design Basics > Understanding the Design Structure","what":"ID Columns","title":"Generating Designs","text":"columns identify structure experiment: profileID: Unique identifier profile (combination attribute levels), corresponds IDs profiles respID: Respondent ID (1 n_resp) qID: Question number within respondent (1 n_q) altID: Alternative number within question (1 n_alts) obsID: Unique identifier choice question across respondents","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"attribute-columns","dir":"Articles","previous_headings":"Design Basics > Understanding the Design Structure","what":"Attribute Columns","title":"Generating Designs","text":"remaining columns represent experimental attributes. default, categorical attributes dummy-coded. dummy coding, continuous attributes (like price) appear -, categorical attributes (like type freshness) split multiple binary columns. example, type, following columns: typeGala = 1 type “Gala”, 0 otherwise typeHoneycrisp = 1 type “Honeycrisp”, 0 otherwise reference level (“Fuji”) represented dummy variables equal 0.","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"converting-to-categorical-format","dir":"Articles","previous_headings":"Design Basics > Understanding the Design Structure","what":"Converting to Categorical Format","title":"Generating Designs","text":"prefer see categorical variables original format, use cbc_decode(): decoded version shows: type categorical variable levels “Fuji”, “Gala”, “Honeycrisp” freshness categorical variable levels “Poor”, “Average”, “Excellent” price remains unchanged (continuous variables don’t need decoding) forms design (dummy-coded categorical) convenient different purposes, though otherwise equivalent.","code":"design_decoded <- cbc_decode(design) design_decoded #> Design method: random #> Structure: 100 respondents × 6 questions × 2 alternatives #> Profile usage: 45/45 (100.0%) #>  #> 💡 Use cbc_inspect() for a more detailed summary #>  #> First few rows of design: #>   profileID respID qID altID obsID price       type freshness #> 1        31      1   1     1     1   1.0       Fuji Excellent #> 2        15      1   1     2     1   3.0 Honeycrisp      Poor #> 3        14      1   2     1     2   2.5 Honeycrisp      Poor #> 4         3      1   2     2     2   2.0       Fuji      Poor #> 5        42      1   3     1     3   1.5 Honeycrisp Excellent #> 6        43      1   3     2     3   2.0 Honeycrisp Excellent #> ... and 1194 more rows"},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"design-methods","dir":"Articles","previous_headings":"","what":"Design Methods","title":"Generating Designs","text":"cbc_design() function supports several design generation methods, different strengths use cases:","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"method-comparison-table","dir":"Articles","previous_headings":"Design Methods","what":"Method Comparison Table","title":"Generating Designs","text":"design methods ensure: duplicate profiles within choice set duplicate choice sets within respondent Dominance removal (enabled) eliminates choice sets dominant alternatives (requires priors)","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"random-method","dir":"Articles","previous_headings":"Design Methods","what":"\"random\" Method","title":"Generating Designs","text":"\"random\" method default creates designs randomly sampling profiles respondent independently. ensures maximum diversity may less statistically efficient. use: Large sample sizes efficiency matters less Want maximum diversity across respondents strong prior assumptions parameters Uncertain whether interactions might important Quick prototyping testing","code":"design_random <- cbc_design(   profiles = profiles,   method = \"random\",   n_alts = 2,   n_q = 6,   n_resp = 100 )  # Quick inspection cbc_inspect(design_random, sections = \"structure\") #> DESIGN SUMMARY #> ========================= #>  #> STRUCTURE #> ================ #> Method: random #> Created: 2025-07-08 11:17:30 #> Respondents: 100 #> Questions per respondent: 6 #> Alternatives per question: 2 #> Total choice sets: 600 #> Profile usage: 45/45 (100.0%)"},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"frequency-based-methods","dir":"Articles","previous_headings":"Design Methods","what":"Frequency-Based Methods","title":"Generating Designs","text":"\"shortcut\", \"minoverlap\", \"balanced\" methods use greedy algorithms balance attribute level frequencies minimize overlap. prioritize different metrics, often can result similar solutions. method different objective: \"shortcut\" method balances attribute level frequencies avoiding duplicate profiles within questions. \"minoverlap\" method prioritizes minimizing attribute overlap within choice questions. \"balanced\" method optimizes frequency balance pairwise attribute interactions.","code":"design_shortcut <- cbc_design(   profiles = profiles,   method = \"shortcut\",   n_alts = 2,   n_q = 6,   n_resp = 100 )  design_minoverlap <- cbc_design(   profiles = profiles,   method = \"minoverlap\",   n_alts = 2,   n_q = 6,   n_resp = 100 )  design_balanced <- cbc_design(   profiles = profiles,   method = \"balanced\",   n_alts = 2,   n_q = 6,   n_resp = 100 )"},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"d-optimal-methods","dir":"Articles","previous_headings":"Design Methods","what":"D-Optimal Methods","title":"Generating Designs","text":"methods minimize D-error create statistically efficient designs. require computation produce higher-quality designs, especially good priors. method different approach: \"stochastic\" method uses random profile swapping minimize d-error, accepting first improvement found. faster algorithm compromise speed exhaustiveness. \"modfed\" (Modified Fedorov) method exhaustively tests possible profile swaps position. slower methods though thorough. \"cea\" (Coordinate Exchange Algorithm) method optimizes attribute--attribute, testing possible levels attribute. faster \"modfed\", though requires possible profiles accept restricted profile sets. Unlike previous methods, methods identify single d-optimal design repeat design across respondent. contrast, methods create unique design respondent. examples , n_start = 1, meaning run one design search (faster), may want run longer search increasing n_start. best design across starts chosen. Notice also examples provided priors design. optimize design around assumed priors minimizing DpD_p-error. uncertain true parameters , can omit priors argument algorithms minimize D0D_0-error. See Computing D-error page details errors computed.","code":"design_stochastic <- cbc_design(   profiles = profiles,   method = \"stochastic\",   n_alts = 2,   n_q = 6,   n_resp = 100,   priors = priors,   n_start = 1 # Number of random starting points )  design_modfed <- cbc_design(   profiles = profiles,   n_alts = 2,   n_q = 6,   n_resp = 100,   priors = priors,   method = \"modfed\",   n_start = 1 )  design_cea <- cbc_design(   profiles = profiles,   n_alts = 2,   n_q = 6,   n_resp = 100,   priors = priors,   method = \"cea\",   n_start = 1 )"},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"comparing-designs","dir":"Articles","previous_headings":"","what":"Comparing Designs","title":"Generating Designs","text":"can compare results different designs using cbc_compare() function. provides comprehensive overview differences structure well common metrics D-error, overlap, balance.","code":"cbc_compare(   \"Random\" = design_random,   \"Shortcut\" = design_shortcut,   \"Min Overlap\" = design_minoverlap,   \"Balanced\" = design_balanced,   \"Stochastic\" = design_stochastic,   \"Modfed\" = design_modfed,   \"CEA\" = design_cea ) #> CBC Design Comparison #> ===================== #> Designs compared: 7 #> Metrics: structure, efficiency, balance, overlap #> Sorted by: d_error (ascending) #>  #> Structure #> ===================== #>       Design     Method respondents questions #>          CEA        cea         100         6 #>       Modfed     modfed         100         6 #>   Stochastic stochastic         100         6 #>       Random     random         100         6 #>     Shortcut   shortcut         100         6 #>  Min Overlap minoverlap         100         6 #>     Balanced   balanced         100         6 #>  Alternatives Blocks Profile Usage #>             2      1 (12/45) 26.7% #>             2      1 (12/45) 26.7% #>             2      1 (12/45) 26.7% #>             2      1  (45/45) 100% #>             2      1  (45/45) 100% #>             2      1  (45/45) 100% #>             2      1  (45/45) 100% #>  No Choice Labeled? #>         No       No #>         No       No #>         No       No #>         No       No #>         No       No #>         No       No #>         No       No #>  #> Design Metrics #> ===================== #>       Design     Method D-Error (Null) D-Error (Prior) Balance Overlap #>          CEA        cea       0.881860        1.009140   0.777   0.233 #>       Modfed     modfed       0.854478        1.023454   0.777   0.233 #>   Stochastic stochastic       1.203841        1.485359   0.686   0.300 #>       Random     random             NA              NA   0.739   0.477 #>     Shortcut   shortcut             NA              NA   0.740   0.267 #>  Min Overlap minoverlap             NA              NA   0.737   0.267 #>     Balanced   balanced             NA              NA   0.741   0.267 #>  #> Interpretation: #> - D-Error: Lower is better (design efficiency) #> - Balance: Higher is better (level distribution) #> - Overlap: Lower is better (attribute variation) #> - Profile Usage: Higher means more profiles used #>  #> Best performers: #> - D-Error: CEA (1.009140) #> - Balance: CEA (0.777) #> - Overlap: CEA (0.233) #> - Profile Usage: Random (100.0%) #>  #> Use summary() for detailed information on any one design."},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"no-choice-option","dir":"Articles","previous_headings":"Design Features","what":"No-Choice Option","title":"Generating Designs","text":"Add “-choice” alternative allow respondents opt including argument no_choice = TRUE. using priors design (optional), must also provide no_choice value priors: Note: Designs -choice options must dummy-coded converted back categorical format.","code":"# For D-optimal methods, must include no_choice in priors priors_nochoice <- cbc_priors(   profiles = profiles,   price = -0.1,   type = c(0.1, 0.2),   freshness = c(0.1, 0.2),   no_choice = -0.5 # Negative value makes no-choice less attractive )  design_nochoice <- cbc_design(   profiles = profiles,   n_alts = 2,   n_q = 6,   n_resp = 100,   no_choice = TRUE,   priors = priors_nochoice,   method = \"stochastic\" )  head(design_nochoice) #> Design method: stochastic #> Structure: 100 respondents × 6 questions × 2 alternatives #> Profile usage: 11/45 (24.4%) #> D-error: 0.809628 #>  #> 💡 Use cbc_inspect() for a more detailed summary #>  #> First few rows of design: #>   profileID blockID respID qID altID obsID price typeGala typeHoneycrisp #> 1        21       1      1   1     1     1   1.0        1              0 #> 2        35       1      1   1     2     1   3.0        0              0 #> 3         0       1      1   1     3     1   0.0        0              0 #> 4        15       1      1   2     1     2   3.0        0              1 #> 5        17       1      1   2     2     2   1.5        0              0 #> 6         0       1      1   2     3     2   0.0        0              0 #>   freshnessAverage freshnessExcellent no_choice #> 1                1                  0         0 #> 2                0                  1         0 #> 3                0                  0         1 #> 4                0                  0         0 #> 5                1                  0         0 #> 6                0                  0         1"},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"labeled-designs","dir":"Articles","previous_headings":"Design Features","what":"Labeled Designs","title":"Generating Designs","text":"Create “labeled” “alternative-specific” designs one attribute serves label using label argument:","code":"design_labeled <- cbc_design(   profiles = profiles,   n_alts = 3, # Will be overridden to match number of type levels   n_q = 6,   n_resp = 100,   label = \"type\", # Use 'type' attribute as labels   method = \"random\" )  head(design_labeled) #> Design method: random #> Structure: 100 respondents × 6 questions × 3 alternatives #> Profile usage: 45/45 (100.0%) #>  #> 💡 Use cbc_inspect() for a more detailed summary #>  #> First few rows of design: #>   profileID respID qID altID obsID price typeGala typeHoneycrisp #> 1        34      1   1     1     1   2.5        0              0 #> 2         9      1   1     2     1   2.5        1              0 #> 3        29      1   1     3     1   2.5        0              1 #> 4        32      1   2     1     2   1.5        0              0 #> 5        25      1   2     2     2   3.0        1              0 #> 6        30      1   2     3     2   3.0        0              1 #>   freshnessAverage freshnessExcellent #> 1                0                  1 #> 2                0                  0 #> 3                1                  0 #> 4                0                  1 #> 5                1                  0 #> 6                1                  0"},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"blocking","dir":"Articles","previous_headings":"Design Features","what":"Blocking","title":"Generating Designs","text":"D-optimal methods, create multiple design blocks reduce respondent burden:","code":"design_blocked <- cbc_design(   profiles = profiles,   n_alts = 2,   n_q = 6,   n_resp = 100,   n_blocks = 2, # Create 2 different design blocks   priors = priors,   method = \"stochastic\" )  # Check block allocation table(design_blocked$blockID) #>  #>   1   2  #> 600 600"},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"dominance-removal","dir":"Articles","previous_headings":"Design Features","what":"Dominance Removal","title":"Generating Designs","text":"Remove choice sets one alternative dominates others based parameter preferences. two forms dominance removal: Total dominance: Occurs one alternative high predicted choice probability (based prior coefficients) chosen virtually respondents. creates choice sets little information value since outcome predetermined. dominance_threshold parameter controls - alternatives choice probabilities threshold (e.g., 0.8 = 80%) considered dominant. Partial dominance: Occurs one alternative superior others across every individual attribute component utility function (, based prior coefficients). example, Alternative higher partial utilities Alternative B every single attribute (price, type, freshness), partially dominates B regardless overall choice probability. type dominance detected comparing attribute-level contributions utility. forms dominance create unrealistic choice scenarios provide less information respondent preferences, removing generally improves design quality.","code":"design_no_dominance <- cbc_design(   profiles = profiles,   n_alts = 2,   n_q = 6,   n_resp = 100,   priors = priors,   method = \"stochastic\",   remove_dominant = TRUE,   dominance_types = c(\"total\", \"partial\"),   dominance_threshold = 0.8 )"},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"interactions","dir":"Articles","previous_headings":"Design Features","what":"Interactions","title":"Generating Designs","text":"Include interaction effects D-optimal designs specifying prior model. Interactions capture effect one attribute depends level another attribute. design optimization accounts interaction terms minimizing D-error. Interactions specified via priors defined cbc_priors(). example: include interactions prior model, design optimization: Accounts interaction parameters computing choice probabilities Optimizes profile combinations provide information main effects interactions Creates choice sets help distinguish different interaction effects leads efficient designs interaction effects truly exist population, can reduce efficiency estimating main effects interactions misspecified don’t actually exist. See Specifying Priors article details options defining priors interactions.","code":"# Create priors with interactions priors_interactions <- cbc_priors(   profiles = profiles,   price = -0.25,   type = c(\"Fuji\" = 0.5, \"Gala\" = 1.0),   freshness = c(0.6, 1.2),   interactions = list(     # Price is less negative (less price sensitive) for Fuji apples     int_spec(       between = c(\"price\", \"type\"),       with_level = \"Fuji\",       value = 0.5     ),     # Price is slightly less negative for Gala apples     int_spec(       between = c(\"price\", \"type\"),       with_level = \"Gala\",       value = 0.2     )     # Honeycrisp uses reference level (no additional interaction term)   ) )  design_interactions <- cbc_design(   profiles = profiles,   n_alts = 2,   n_q = 6,   n_resp = 100,   priors = priors_interactions,   method = \"stochastic\" )"},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"comprehensive-design-inspection","dir":"Articles","previous_headings":"","what":"Comprehensive Design Inspection","title":"Generating Designs","text":"Use cbc_inspect() detailed design analysis:","code":"# Detailed inspection of the stochastic design cbc_inspect(   design_stochastic,   sections = \"all\" ) #> DESIGN SUMMARY #> ========================= #>  #> STRUCTURE #> ================ #> Method: stochastic #> Created: 2025-07-08 11:17:42 #> Respondents: 100 #> Questions per respondent: 6 #> Alternatives per question: 2 #> Total choice sets: 600 #> Profile usage: 12/45 (26.7%) #>  #> SUMMARY METRICS #> ================= #> D-error (with priors): 1.485359 #> D-error (null model): 1.203841 #> (Lower values indicate more efficient designs) #>  #> Overall balance score: 0.686 (higher is better) #> Overall overlap score: 0.300 (lower is better) #>  #> VARIABLE ENCODING #> ================= #> Format: Dummy-coded (type, freshness) #> 💡 Use cbc_decode_design() to convert to categorical format #>  #> ATTRIBUTE BALANCE #> ================= #> Overall balance score: 0.686 (higher is better) #>  #> Individual attribute level counts: #>  #> price: #>  #>   1 1.5   2 2.5   3  #> 300 200 200 400 100  #>   Balance score: 0.678 (higher is better) #>  #> typeGala: #>  #>   0   1  #> 800 400  #>   Balance score: 0.680 (higher is better) #>  #> typeHoneycrisp: #>  #>   0   1  #> 900 300  #>   Balance score: 0.586 (higher is better) #>  #> freshnessAverage: #>  #>   0   1  #> 700 500  #>   Balance score: 0.809 (higher is better) #>  #> freshnessExcellent: #>  #>   0   1  #> 800 400  #>   Balance score: 0.680 (higher is better) #>  #> ATTRIBUTE OVERLAP #> ================= #> Overall overlap score: 0.300 (lower is better) #>  #> Counts of attribute overlap: #> (# of questions with N unique levels) #>  #> price: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):  16.7%  (100 / 600 questions) #>   2 (partial overlap):   83.3%  (500 / 600 questions) #>   3 (partial overlap):    0.0%  (0 / 600 questions) #>   4 (partial overlap):    0.0%  (0 / 600 questions) #>   5 (no overlap):         0.0%  (0 / 600 questions) #>   Average unique levels per question: 1.83 #>  #> typeGala: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):  33.3%  (200 / 600 questions) #>   2 (no overlap):        66.7%  (400 / 600 questions) #>   Average unique levels per question: 1.67 #>  #> typeHoneycrisp: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):  50.0%  (300 / 600 questions) #>   2 (no overlap):        50.0%  (300 / 600 questions) #>   Average unique levels per question: 1.50 #>  #> freshnessAverage: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):  16.7%  (100 / 600 questions) #>   2 (no overlap):        83.3%  (500 / 600 questions) #>   Average unique levels per question: 1.83 #>  #> freshnessExcellent: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):  33.3%  (200 / 600 questions) #>   2 (no overlap):        66.7%  (400 / 600 questions) #>   Average unique levels per question: 1.67"},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"customizing-optimization","dir":"Articles","previous_headings":"Comprehensive Design Inspection","what":"Customizing Optimization","title":"Generating Designs","text":"cbc_design() function offers many customization options:","code":"# Advanced stochastic design with custom settings design_advanced <- cbc_design(   profiles = profiles,   n_alts = 2,   n_q = 8,   n_resp = 300,   n_blocks = 2,   priors = priors,   method = \"stochastic\",   n_start = 10, # More starting points for better optimization   max_iter = 100, # More iterations per start   n_cores = 4, # Parallel processing   remove_dominant = TRUE,   dominance_threshold = 0.9,   randomize_questions = TRUE,   randomize_alts = TRUE )"},{"path":"https://jhelvy.github.io/cbcTools/articles/design.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Generating Designs","text":"generating design: Inspect design using cbc_inspect() understand properties Simulate choices using cbc_choices() test design Conduct power analysis using cbc_power() determine sample size requirements Compare alternatives using cbc_compare() choose best design details next steps, see: Simulating Choices vignette Power Analysis vignette","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/getting-started.html","id":"the-cbctools-workflow","dir":"Articles","previous_headings":"","what":"The cbcTools Workflow","title":"Getting Started","text":"package supports step--step process developing choice experiment designs: step uses functions begin cbc_ builds previous step: Generate Profiles → cbc_profiles() - Define attributes levels Specify Priors → cbc_priors() - Specify prior preference assumptions (optional) Generate Designs → cbc_design() - Create choice question design Inspect Designs → cbc_inspect() - Evaluate design quality Simulate Choices → cbc_choices() - Generate realistic choice data Assess Power → cbc_power() - Determine sample size requirements Let’s walk step complete example. Imagine ’re designing choice experiment understand consumer preferences apples. want study price, type, freshness influence purchase decisions.","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/getting-started.html","id":"step-1-generate-profiles","dir":"Articles","previous_headings":"The cbcTools Workflow","what":"Step 1: Generate Profiles","title":"Getting Started","text":"Start defining attributes levels experiment: creates possible combinations attribute levels - “universe” possible products include choice questions. See Generating Profiles article details options defining profiles, including restrictions.","code":"profiles <- cbc_profiles(   price = c(1.0, 1.5, 2.0, 2.5, 3.0), # Price per pound ($)   type = c('Fuji', 'Gala', 'Honeycrisp'),   freshness = c('Poor', 'Average', 'Excellent') )  profiles #> CBC Profiles #> ============ #> price       : Continuous (5 levels, range: 1.00-3.00) #> type        : Categorical (3 levels: Fuji, Gala, Honeycrisp) #> freshness   : Categorical (3 levels: Poor, Average, Excellent) #>  #> Profiles: 45 #> First few rows: #>   profileID price type freshness #> 1         1   1.0 Fuji      Poor #> 2         2   1.5 Fuji      Poor #> 3         3   2.0 Fuji      Poor #> 4         4   2.5 Fuji      Poor #> 5         5   3.0 Fuji      Poor #> 6         6   1.0 Gala      Poor #> ... and 39 more rows"},{"path":"https://jhelvy.github.io/cbcTools/articles/getting-started.html","id":"step-2-specify-priors","dir":"Articles","previous_headings":"The cbcTools Workflow","what":"Step 2: Specify Priors","title":"Getting Started","text":"Specify assumptions consumer preferences based theory, literature, pilot studies. can used generating designs incorporate expected preferences well simulating choices given design.","code":"priors <- cbc_priors(   profiles = profiles,   price = -0.25, # Negative = people prefer lower prices   type = c(0.5, 1), # Gala and Honeycrisp preferred over Fuji (reference)   freshness = c(0.6, 1.2) # Average and Excellent preferred over Poor (reference) )  priors #> CBC Prior Specifications: #>  #> price: #>   Continuous variable #>   Levels: 1, 1.5, 2, 2.5, 3  #>   Fixed parameter #>     Coefficient: -0.25 #>  #> type: #>   Categorical variable #>   Levels: Fuji, Gala, Honeycrisp  #>   Reference level: Fuji #>   Fixed parameter #>     Gala: 0.5 #>     Honeycrisp: 1 #>  #> freshness: #>   Categorical variable #>   Levels: Poor, Average, Excellent  #>   Reference level: Poor #>   Fixed parameter #>     Average: 0.6 #>     Excellent: 1.2"},{"path":"https://jhelvy.github.io/cbcTools/articles/getting-started.html","id":"understanding-reference-levels","dir":"Articles","previous_headings":"The cbcTools Workflow > Step 2: Specify Priors","what":"Understanding Reference Levels","title":"Getting Started","text":"categorical attributes, reference level set first level defined cbc_profiles(), case \"Fuji\" Type \"Poor\" Freshness. imply following set priors: Type: Fuji (reference), Gala (+0.5), Honeycrisp (+1.0) Freshness: Poor (reference), Average (+0.6), Excellent (+1.2) See Specifying Priors article details options defining priors.","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/getting-started.html","id":"step-3-generate-designs","dir":"Articles","previous_headings":"The cbcTools Workflow","what":"Step 3: Generate Designs","title":"Getting Started","text":"Create set choice questions respondents see. default, categorical variables dummy-coded resulting design (can convert design back categorical formatting cbc_decode()): design generated sufficient full survey n_resp respondents. cbcTools offers several design methods, trade-offs: \"random\": Random profiles respondent. \"shortcut\": Frequency-balanced, often results minimal overlap within choice questions. \"minoverlap\": Prioritizes minimizing attribute overlap within choice questions. \"balanced\": Optimizes frequency balance pairwise attribute interactions. \"stochastic\": Minimizes D-error randomly swapping profiles. \"modfed\": Minimizes D-error swapping possible profiles (slower, thorough). \"cea\": Minimizes D-error attribute--attribute swapping. design methods ensure: duplicate profiles within choice set. duplicate choice sets within respondent. Dominance removal (enabled) eliminates choice sets dominant alternatives. See Generating Designs article details options generating experiment designs, including “choice” options, using labeled designs, removing dominant options, details design algorithm.","code":"design <- cbc_design(   profiles = profiles,   method = \"stochastic\", # D-optimal method   n_alts = 3, # 2 alternatives per choice question   n_q = 6, # 6 questions per respondent   n_resp = 300, # 300 respondents   priors = priors # Use our priors for optimization )  design #> Design method: stochastic #> Structure: 300 respondents × 6 questions × 3 alternatives #> Profile usage: 18/45 (40.0%) #> D-error: 0.840469 #>  #> 💡 Use cbc_inspect() for a more detailed summary #>  #> First few rows of design: #>   profileID blockID respID qID altID obsID price typeGala typeHoneycrisp #> 1        22       1      1   1     1     1   1.5        1              0 #> 2         1       1      1   1     2     1   1.0        0              0 #> 3        35       1      1   1     3     1   3.0        0              0 #> 4        15       1      1   2     1     2   3.0        0              1 #> 5        25       1      1   2     2     2   3.0        1              0 #> 6        31       1      1   2     3     2   1.0        0              0 #>   freshnessAverage freshnessExcellent #> 1                1                  0 #> 2                0                  0 #> 3                0                  1 #> 4                0                  0 #> 5                1                  0 #> 6                0                  1 #> ... and 5394 more rows"},{"path":"https://jhelvy.github.io/cbcTools/articles/getting-started.html","id":"step-4-inspect-design","dir":"Articles","previous_headings":"The cbcTools Workflow","what":"Step 4: Inspect Design","title":"Getting Started","text":"Use cbc_inspect() function evaluate quality properties design. Key things look : D-error: Lower values indicate efficient designs Balance: Higher scores indicate better attribute level balance Overlap: Lower scores indicate less attribute overlap within questions Profile usage: Higher percentages indicate better use available profiles See cbc_inspect details.","code":"cbc_inspect(design) #> DESIGN SUMMARY #> ========================= #>  #> STRUCTURE #> ================ #> Method: stochastic #> Created: 2025-07-08 11:17:55 #> Respondents: 300 #> Questions per respondent: 6 #> Alternatives per question: 3 #> Total choice sets: 1800 #> Profile usage: 18/45 (40.0%) #>  #> SUMMARY METRICS #> ================= #> D-error (with priors): 0.840469 #> D-error (null model): 0.815071 #> (Lower values indicate more efficient designs) #>  #> Overall balance score: 0.623 (higher is better) #> Overall overlap score: 0.167 (lower is better) #>  #> VARIABLE ENCODING #> ================= #> Format: Dummy-coded (type, freshness) #> 💡 Use cbc_decode_design() to convert to categorical format #>  #> ATTRIBUTE BALANCE #> ================= #> Overall balance score: 0.623 (higher is better) #>  #> Individual attribute level counts: #>  #> price: #>  #>    1  1.5    2    3  #> 1500 1200  300 2400  #>   Balance score: 0.609 (higher is better) #>  #> typeGala: #>  #>    0    1  #> 3900 1500  #>   Balance score: 0.614 (higher is better) #>  #> typeHoneycrisp: #>  #>    0    1  #> 3900 1500  #>   Balance score: 0.614 (higher is better) #>  #> freshnessAverage: #>  #>    0    1  #> 3300 2100  #>   Balance score: 0.761 (higher is better) #>  #> freshnessExcellent: #>  #>    0    1  #> 4500  900  #>   Balance score: 0.515 (higher is better) #>  #> ATTRIBUTE OVERLAP #> ================= #> Overall overlap score: 0.167 (lower is better) #>  #> Counts of attribute overlap: #> (# of questions with N unique levels) #>  #> price: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):   0.0%  (0 / 1800 questions) #>   2 (partial overlap):   33.3%  (600 / 1800 questions) #>   3 (partial overlap):   66.7%  (1200 / 1800 questions) #>   4 (no overlap):         0.0%  (0 / 1800 questions) #>   Average unique levels per question: 2.67 #>  #> typeGala: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):  16.7%  (300 / 1800 questions) #>   2 (no overlap):        83.3%  (1500 / 1800 questions) #>   Average unique levels per question: 1.83 #>  #> typeHoneycrisp: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):  16.7%  (300 / 1800 questions) #>   2 (no overlap):        83.3%  (1500 / 1800 questions) #>   Average unique levels per question: 1.83 #>  #> freshnessAverage: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):   0.0%  (0 / 1800 questions) #>   2 (no overlap):       100.0%  (1800 / 1800 questions) #>   Average unique levels per question: 2.00 #>  #> freshnessExcellent: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):  50.0%  (900 / 1800 questions) #>   2 (no overlap):        50.0%  (900 / 1800 questions) #>   Average unique levels per question: 1.50"},{"path":"https://jhelvy.github.io/cbcTools/articles/getting-started.html","id":"step-5-simulate-choices","dir":"Articles","previous_headings":"The cbcTools Workflow","what":"Step 5: Simulate Choices","title":"Getting Started","text":"Generate realistic choice data test design cbc_choices() function. default, random choices made, provide priors priors argument, choices made according utility model defined priors: Taking look quick summaries, can see simulated choice patterns align priors - lower prices, preferred apple types, better freshness chosen often (always levels though level randomness involved). , ’s often easier work design categorical coding instead dummy coding: See Simulating Choices article details options inspeciting comparing different experiment designs.","code":"# Simulate choices using our priors choices <- cbc_choices(design, priors = priors)  choices #> CBC Choice Data #> =============== #> Observations: 1800 choice tasks #> Alternatives per task: 3 #> Respondents: 300 #> Questions per respondent: 6 #> Total choices made: 1800 #>  #> Simulation method: utility_based #> Original design D-error: 0.840469 #> Priors: Used for utility-based simulation #> Simulated at: 2025-07-08 11:17:56 #>  #> Choice rates by alternative: #>   Alt 1: 32.7% (588 choices) #>   Alt 2: 32.5% (585 choices) #>   Alt 3: 34.8% (627 choices) #>  #> First few rows: #>   profileID blockID respID qID altID obsID price typeGala typeHoneycrisp #> 1        22       1      1   1     1     1   1.5        1              0 #> 2         1       1      1   1     2     1   1.0        0              0 #> 3        35       1      1   1     3     1   3.0        0              0 #> 4        15       1      1   2     1     2   3.0        0              1 #> 5        25       1      1   2     2     2   3.0        1              0 #> 6        31       1      1   2     3     2   1.0        0              0 #>   freshnessAverage freshnessExcellent choice #> 1                1                  0      1 #> 2                0                  0      0 #> 3                0                  1      0 #> 4                0                  0      0 #> 5                1                  0      0 #> 6                0                  1      1 #> ... and 5394 more rows choices_cat <- cbc_decode(choices)  # Filter for the chosen rows only choices_cat <- choices_cat[which(choices_cat$choice == 1), ]  # Counts of choices made for each attribute level table(choices_cat$price) #>  #>   1 1.5   2   3  #> 522 508  70 700 table(choices_cat$type) #>  #>       Fuji       Gala Honeycrisp  #>        560        511        729 table(choices_cat$freshness) #>  #>      Poor   Average Excellent  #>       630       810       360"},{"path":"https://jhelvy.github.io/cbcTools/articles/getting-started.html","id":"step-6-assess-power","dir":"Articles","previous_headings":"The cbcTools Workflow","what":"Step 6: Assess Power","title":"Getting Started","text":"Determine sample size provides adequate statistical power. cbc_power() function auto-determines attributes design estimates multiple logit models using incrementally increasing sample sizes assess power: can easily visualize results well using plot() function:  Finally, using summary() function can determine exact size required identify attribute: See Power article details options conducting power analyses better understand experiment designs.","code":"power <- cbc_power(choices) power #> CBC Power Analysis Results #> ========================== #>  #> Sample sizes tested: 30 to 300 (10 breaks) #> Significance level: 0.050 #> Parameters: price, typeGala, typeHoneycrisp, freshnessAverage, freshnessExcellent #>  #> Power summary (probability of detecting true effect): #>  #> n = 30: #>   price       : Power = 0.558, SE = 0.0939 #>   typeGala    : Power = 0.685, SE = 0.2184 #>   typeHoneycrisp: Power = 1.000, SE = 0.2182 #>   freshnessAverage: Power = 0.769, SE = 0.1812 #>   freshnessExcellent: Power = 0.994, SE = 0.2626 #>  #> n = 90: #>   price       : Power = 0.914, SE = 0.0537 #>   typeGala    : Power = 0.992, SE = 0.1231 #>   typeHoneycrisp: Power = 1.000, SE = 0.1233 #>   freshnessAverage: Power = 0.999, SE = 0.1028 #>   freshnessExcellent: Power = 1.000, SE = 0.1510 #>  #> n = 180: #>   price       : Power = 1.000, SE = 0.0380 #>   typeGala    : Power = 1.000, SE = 0.0865 #>   typeHoneycrisp: Power = 1.000, SE = 0.0876 #>   freshnessAverage: Power = 1.000, SE = 0.0735 #>   freshnessExcellent: Power = 1.000, SE = 0.1075 #>  #> n = 240: #>   price       : Power = 1.000, SE = 0.0329 #>   typeGala    : Power = 1.000, SE = 0.0748 #>   typeHoneycrisp: Power = 1.000, SE = 0.0753 #>   freshnessAverage: Power = 1.000, SE = 0.0631 #>   freshnessExcellent: Power = 1.000, SE = 0.0927 #>  #> n = 300: #>   price       : Power = 1.000, SE = 0.0295 #>   typeGala    : Power = 1.000, SE = 0.0667 #>   typeHoneycrisp: Power = 1.000, SE = 0.0675 #>   freshnessAverage: Power = 1.000, SE = 0.0564 #>   freshnessExcellent: Power = 1.000, SE = 0.0832 #>  #> Use plot() to visualize power curves. #> Use summary() for detailed power analysis. plot(power, type = \"power\", power_threshold = 0.9) summary(power, power_threshold = 0.9) #> CBC Power Analysis Summary #> =========================== #>  #> Sample size requirements for 90% power: #>  #> price          : n >= 90 (achieves 91.4% power, SE = 0.0537) #> typeGala       : n >= 60 (achieves 97.2% power, SE = 0.1514) #> typeHoneycrisp : n >= 30 (achieves 100.0% power, SE = 0.2182) #> freshnessAverage: n >= 60 (achieves 99.2% power, SE = 0.1269) #> freshnessExcellent: n >= 30 (achieves 99.4% power, SE = 0.2626)"},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"what-is-statistical-power","dir":"Articles","previous_headings":"Understanding Power Analysis","what":"What is Statistical Power?","title":"Power Analysis","text":"Statistical power probability correctly detecting effect truly exists. choice experiments, power depends : Effect size: Larger effects easier detect Sample size: respondents provide precision Design efficiency: Better designs extract information per respondent Model complexity: parameters require larger samples","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"why-conduct-power-analysis","dir":"Articles","previous_headings":"Understanding Power Analysis","what":"Why Conduct Power Analysis?","title":"Power Analysis","text":"Sample size planning: Determine minimum respondents needed Budget planning: Estimate data collection costs Design comparison: Choose alternative experimental designs Feasibility assessment: Check research questions answerable available resources","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"power-vs--precision","dir":"Articles","previous_headings":"Understanding Power Analysis","what":"Power vs. Precision","title":"Power Analysis","text":"Power analysis cbc_power() focuses precision (standard errors) rather traditional hypothesis testing power, : Provides actionable information sample size planning Relevant significant non-significant results Easier interpret across different effect sizes directly tied practical research needs","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"basic-power-analysis","dir":"Articles","previous_headings":"","what":"Basic Power Analysis","title":"Power Analysis","text":"Start basic power analysis using auto-detection parameters:","code":"# Basic power analysis with auto-detected parameters power_basic <- cbc_power(   data = choices,   outcome = \"choice\",   obsID = \"obsID\",   n_q = 6,   n_breaks = 10 )  # View the power analysis object power_basic #> CBC Power Analysis Results #> ========================== #>  #> Sample sizes tested: 60 to 600 (10 breaks) #> Significance level: 0.050 #> Parameters: price, typeGala, typeHoneycrisp, freshnessAverage, freshnessExcellent #>  #> Power summary (probability of detecting true effect): #>  #> n = 60: #>   price       : Power = 0.376, SE = 0.1163 #>   typeGala    : Power = 0.882, SE = 0.2116 #>   typeHoneycrisp: Power = 0.999, SE = 0.2144 #>   freshnessAverage: Power = 0.797, SE = 0.2052 #>   freshnessExcellent: Power = 1.000, SE = 0.2244 #>  #> n = 180: #>   price       : Power = 0.983, SE = 0.0667 #>   typeGala    : Power = 0.993, SE = 0.1137 #>   typeHoneycrisp: Power = 1.000, SE = 0.1194 #>   freshnessAverage: Power = 1.000, SE = 0.1147 #>   freshnessExcellent: Power = 1.000, SE = 0.1205 #>  #> n = 360: #>   price       : Power = 1.000, SE = 0.0463 #>   typeGala    : Power = 1.000, SE = 0.0807 #>   typeHoneycrisp: Power = 1.000, SE = 0.0841 #>   freshnessAverage: Power = 1.000, SE = 0.0831 #>   freshnessExcellent: Power = 1.000, SE = 0.0872 #>  #> n = 480: #>   price       : Power = 1.000, SE = 0.0403 #>   typeGala    : Power = 1.000, SE = 0.0694 #>   typeHoneycrisp: Power = 1.000, SE = 0.0728 #>   freshnessAverage: Power = 1.000, SE = 0.0714 #>   freshnessExcellent: Power = 1.000, SE = 0.0741 #>  #> n = 600: #>   price       : Power = 1.000, SE = 0.0362 #>   typeGala    : Power = 1.000, SE = 0.0620 #>   typeHoneycrisp: Power = 1.000, SE = 0.0655 #>   freshnessAverage: Power = 1.000, SE = 0.0638 #>   freshnessExcellent: Power = 1.000, SE = 0.0668 #>  #> Use plot() to visualize power curves. #> Use summary() for detailed power analysis.  # Access the detailed results data frame head(power_basic$power_summary) #>   sample_size          parameter   estimate  std_error t_statistic     power #> 1          60              price -0.1910977 0.11625005    1.643850 0.3761148 #> 2          60           typeGala  0.6653365 0.21160734    3.144203 0.8818410 #> 3          60     typeHoneycrisp  1.0970572 0.21442926    5.116173 0.9992008 #> 4          60   freshnessAverage  0.5729977 0.20520714    2.792289 0.7973884 #> 5          60 freshnessExcellent  1.4156784 0.22440157    6.308683 0.9999932 #> 6         120              price -0.2159881 0.08224018    2.626309 0.7474069 tail(power_basic$power_summary) #>    sample_size          parameter   estimate  std_error t_statistic power #> 45         540 freshnessExcellent  1.1001963 0.07013045   15.687856     1 #> 46         600              price -0.2852389 0.03622604    7.873862     1 #> 47         600           typeGala  0.5435753 0.06197232    8.771259     1 #> 48         600     typeHoneycrisp  1.0169146 0.06550545   15.524122     1 #> 49         600   freshnessAverage  0.6440423 0.06384102   10.088220     1 #> 50         600 freshnessExcellent  1.1218315 0.06676258   16.803298     1"},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"auto-detection-recommended","dir":"Articles","previous_headings":"Basic Power Analysis > Parameter Specification Options","what":"Auto-Detection (Recommended)","title":"Power Analysis","text":"default, cbc_power() automatically detects attribute parameters choice data:","code":"# Auto-detection works with dummy-coded data power_auto <- cbc_power(   data = choices,   outcome = \"choice\",   obsID = \"obsID\",   n_q = 6,   n_breaks = 8 )  # Shows all parameters: price, typeGala, typeHoneycrisp, freshnessAverage, freshnessExcellent"},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"specify-dummy-coded-parameters","dir":"Articles","previous_headings":"Basic Power Analysis > Parameter Specification Options","what":"Specify Dummy-Coded Parameters","title":"Power Analysis","text":"can explicitly specify dummy-coded parameters include:","code":"# Focus on specific dummy-coded parameters power_specific <- cbc_power(   data = choices,   pars = c(     # Specific dummy variables     \"price\",     \"typeHoneycrisp\",     \"freshnessExcellent\"   ),   outcome = \"choice\",   obsID = \"obsID\",   n_q = 6,   n_breaks = 8 )"},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"use-decoded-data-with-attribute-names","dir":"Articles","previous_headings":"Basic Power Analysis > Parameter Specification Options","what":"Use Decoded Data with Attribute Names","title":"Power Analysis","text":"easier interpretation, decode choice data first use original attribute names:","code":"# Decode choice data to get back categorical variables choices_decoded <- cbc_decode(choices)  # Now you can use attribute names instead of dummy variables power_decoded <- cbc_power(   data = choices_decoded,   pars = c(\"price\", \"type\", \"freshness\"), # Original attribute names   outcome = \"choice\",   obsID = \"obsID\",   n_q = 6,   n_breaks = 8 )  # Note: This approach estimates effects differently - # it treats categorical variables as factors rather than separate dummy variables"},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"when-to-use-each-approach","dir":"Articles","previous_headings":"Basic Power Analysis > Parameter Specification Options","what":"When to Use Each Approach","title":"Power Analysis","text":"Auto-detection: Best comprehensive power analysis effects Dummy-coded specification: want focus specific levels categorical variables Decoded data: want power analysis attribute level rather level-specific effects, easier interpretation","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"understanding-power-results","dir":"Articles","previous_headings":"Basic Power Analysis","what":"Understanding Power Results","title":"Power Analysis","text":"power analysis returns list object several components: power_summary: Data frame sample sizes, coefficients, estimates, standard errors, t-statistics, power sample_sizes: Vector sample sizes tested n_breaks: Number breaks used alpha: Significance level used choice_info: Information underlying choice simulation power_summary data frame contains: sample_size: Number respondents analysis parameter: Parameter name estimated estimate: Coefficient estimate std_error: Standard error estimate t_statistic: t-statistic (estimate/std_error) power: Statistical power (probability detecting effect)","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"visualizing-power-curves","dir":"Articles","previous_headings":"Basic Power Analysis","what":"Visualizing Power Curves","title":"Power Analysis","text":"Plot power curves visualize relationship sample size precision:","code":"# Plot power curves plot(   power_basic,   type = \"power\",   power_threshold = 0.9 ) # Plot standard error curves plot(   power_basic,   type = \"se\" )"},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"interpreting-results","dir":"Articles","previous_headings":"Basic Power Analysis","what":"Interpreting Results","title":"Power Analysis","text":"results, can determine: parameters need largest samples Whether planned sample size adequate much precision improves additional respondents","code":"# Sample size requirements for 90% power summary(   power_basic,   power_threshold = 0.9 ) #> CBC Power Analysis Summary #> =========================== #>  #> Sample size requirements for 90% power: #>  #> price          : n >= 180 (achieves 98.3% power, SE = 0.0667) #> typeGala       : n >= 120 (achieves 97.1% power, SE = 0.1394) #> typeHoneycrisp : n >= 60 (achieves 99.9% power, SE = 0.2144) #> freshnessAverage: n >= 120 (achieves 98.9% power, SE = 0.1426) #> freshnessExcellent: n >= 60 (achieves 100.0% power, SE = 0.2244)"},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"mixed-logit-models","dir":"Articles","previous_headings":"Basic Power Analysis","what":"Mixed Logit Models","title":"Power Analysis","text":"Conduct power analysis random parameter models:","code":"# Create choices with random parameters priors_random <- cbc_priors(   profiles = profiles,   price = rand_spec(     dist = \"n\",     mean = -0.25,     sd = 0.1   ),   type = rand_spec(     dist = \"n\",     mean = c(0.5, 1.0),     sd = c(0.5, 0.5)   ),   freshness = c(0.6, 1.2) )  choices_mixed <- cbc_choices(   design,   priors = priors_random )  # Power analysis for mixed logit model power_mixed <- cbc_power(   data = cbc_decode(choices_mixed),   pars = c(\"price\", \"type\", \"freshness\"),   randPars = c(price = \"n\", type = \"n\"), # Specify random parameters   outcome = \"choice\",   obsID = \"obsID\",   panelID = \"respID\", # Required for panel data   n_q = 6,   n_breaks = 10 )  # Mixed logit models generally require larger samples power_mixed #> CBC Power Analysis Results #> ========================== #>  #> Sample sizes tested: 60 to 600 (10 breaks) #> Significance level: 0.050 #> Parameters: price, typeGala, typeHoneycrisp, freshnessAverage, freshnessExcellent, sd_price, sd_typeGala, sd_typeHoneycrisp #>  #> Power summary (probability of detecting true effect): #>  #> n = 60: #>   price       : Power = 0.806, SE = 0.1315 #>   typeGala    : Power = 0.907, SE = 0.2277 #>   typeHoneycrisp: Power = 0.999, SE = 0.2483 #>   freshnessAverage: Power = 0.773, SE = 0.2155 #>   freshnessExcellent: Power = 1.000, SE = 0.2434 #>   sd_price    : Power = 0.131, SE = 0.3657 #>   sd_typeGala : Power = 0.137, SE = 0.5345 #>   sd_typeHoneycrisp: Power = 0.050, SE = 0.8205 #>  #> n = 180: #>   price       : Power = 0.976, SE = 0.0726 #>   typeGala    : Power = 1.000, SE = 0.1190 #>   typeHoneycrisp: Power = 1.000, SE = 0.1309 #>   freshnessAverage: Power = 0.917, SE = 0.1150 #>   freshnessExcellent: Power = 1.000, SE = 0.1255 #>   sd_price    : Power = 0.050, SE = 0.3522 #>   sd_typeGala : Power = 0.050, SE = 0.3891 #>   sd_typeHoneycrisp: Power = 0.051, SE = 0.9933 #>  #> n = 360: #>   price       : Power = 1.000, SE = 0.0479 #>   typeGala    : Power = 1.000, SE = 0.0837 #>   typeHoneycrisp: Power = 1.000, SE = 0.0902 #>   freshnessAverage: Power = 1.000, SE = 0.0820 #>   freshnessExcellent: Power = 1.000, SE = 0.0871 #>   sd_price    : Power = 0.050, SE = 0.1573 #>   sd_typeGala : Power = 0.050, SE = 0.4394 #>   sd_typeHoneycrisp: Power = 0.050, SE = 0.4378 #>  #> n = 480: #>   price       : Power = 1.000, SE = 0.0417 #>   typeGala    : Power = 1.000, SE = 0.0716 #>   typeHoneycrisp: Power = 1.000, SE = 0.0754 #>   freshnessAverage: Power = 1.000, SE = 0.0709 #>   freshnessExcellent: Power = 1.000, SE = 0.0744 #>   sd_price    : Power = 0.050, SE = 0.1469 #>   sd_typeGala : Power = 0.050, SE = 0.3126 #>   sd_typeHoneycrisp: Power = 0.050, SE = 0.2305 #>  #> n = 600: #>   price       : Power = 1.000, SE = 0.0384 #>   typeGala    : Power = 1.000, SE = 0.0691 #>   typeHoneycrisp: Power = 1.000, SE = 0.0672 #>   freshnessAverage: Power = 1.000, SE = 0.0631 #>   freshnessExcellent: Power = 1.000, SE = 0.0667 #>   sd_price    : Power = 0.051, SE = 0.2043 #>   sd_typeGala : Power = 0.050, SE = 0.5980 #>   sd_typeHoneycrisp: Power = 0.050, SE = 0.1851 #>  #> Use plot() to visualize power curves. #> Use summary() for detailed power analysis."},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"design-method-comparison","dir":"Articles","previous_headings":"Comparing Design Performance","what":"Design Method Comparison","title":"Power Analysis","text":"Compare power across different design methods:","code":"# Create designs with different methods design_random <- cbc_design(   profiles,   n_alts = 2,   n_q = 6,   n_resp = 200,   method = \"random\" ) design_shortcut <- cbc_design(   profiles,   n_alts = 2,   n_q = 6,   n_resp = 200,   method = \"shortcut\" ) design_optimal <- cbc_design(   profiles,   n_alts = 2,   n_q = 6,   n_resp = 200,   priors = priors,   method = \"stochastic\" )  # Simulate choices with same priors for fair comparison choices_random <- cbc_choices(   design_random,   priors = priors ) choices_shortcut <- cbc_choices(   design_shortcut,   priors = priors ) choices_optimal <- cbc_choices(   design_optimal,   priors = priors )  # Conduct power analysis for each power_random <- cbc_power(   choices_random,   n_breaks = 8 ) power_shortcut <- cbc_power(   choices_shortcut,   n_breaks = 8 ) power_optimal <- cbc_power(   choices_optimal,   n_breaks = 8 )  # Compare power curves plot_compare_power(   Random = power_random,   Shortcut = power_shortcut,   Optimal = power_optimal,   type = \"power\" )"},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"returning-full-models","dir":"Articles","previous_headings":"Advanced Analysis","what":"Returning Full Models","title":"Power Analysis","text":"Access complete model objects detailed analysis:","code":"# Return full models for additional analysis power_with_models <- cbc_power(   data = choices,   outcome = \"choice\",   obsID = \"obsID\",   n_q = 6,   n_breaks = 5,   return_models = TRUE )  # Examine largest model largest_model <- power_with_models$models[[length(power_with_models$models)]] summary(largest_model) #> ================================================= #>  #> Model estimated on: Tue Jul 08 11:18:26 2025  #>  #> Using logitr version: 1.1.2  #>  #> Call: #> logitr::logitr(data = data_subset, outcome = outcome, obsID = obsID,  #>     pars = pars, randPars = randPars, panelID = panelID) #>  #> Frequencies of alternatives: #>      1      2  #> 0.4875 0.5125  #>  #> Exit Status: 3, Optimization stopped because ftol_rel or ftol_abs was reached. #>                                  #> Model Type:    Multinomial Logit #> Model Space:          Preference #> Model Run:                1 of 1 #> Iterations:                   11 #> Elapsed Time:        0h:0m:0.01s #> Algorithm:        NLOPT_LD_LBFGS #> Weights Used?:             FALSE #> Panel ID:                 respID #> Robust?                    FALSE #>  #> Model Coefficients:  #>                     Estimate Std. Error z-value  Pr(>|z|)     #> price              -0.285239   0.036226 -7.8739 3.331e-15 *** #> typeGala            0.543575   0.061972  8.7713 < 2.2e-16 *** #> typeHoneycrisp      1.016915   0.065505 15.5241 < 2.2e-16 *** #> freshnessAverage    0.644042   0.063841 10.0882 < 2.2e-16 *** #> freshnessExcellent  1.121831   0.066763 16.8033 < 2.2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>                                       #> Log-Likelihood:         -2193.7218152 #> Null Log-Likelihood:    -2495.3298500 #> AIC:                     4397.4436304 #> BIC:                     4428.3871000 #> McFadden R2:                0.1208690 #> Adj McFadden R2:            0.1188653 #> Number of Observations:  3600.0000000"},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/articles/power.html","id":"power-analysis-workflow","dir":"Articles","previous_headings":"Best Practices","what":"Power Analysis Workflow","title":"Power Analysis","text":"Start literature: Base effect size assumptions previous studies Use realistic priors: Conservative estimates often better optimistic ones Test multiple scenarios: Conservative, moderate, optimistic effect sizes Compare designs: Test different design methods features Plan attrition: Add 10-20% account incomplete responses Document assumptions: Record assumptions future reference","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"what-are-priors","dir":"Articles","previous_headings":"","what":"What Are Priors?","title":"Specifying Priors","text":"Priors represent beliefs attributes influence respondent choices collecting data. specify: Direction effects: Positive values increase utility, negative values decrease . Magnitude effects: Larger absolute values indicate stronger preferences. Heterogeneity effects: Random parameters can used specify heterogeneity preferences across population.","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"sources-of-prior-information","dir":"Articles","previous_headings":"What Are Priors?","what":"Sources of Prior Information","title":"Specifying Priors","text":"Literature review: Published studies similar contexts. Expert judgment: Domain knowledge researchers practitioners. Pilot studies: Small preliminary studies estimate effects. Previous studies: past research related areas. Theoretical expectations: Economic theory behavioral assumptions.","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"basic-prior-specification","dir":"Articles","previous_headings":"","what":"Basic Prior Specification","title":"Specifying Priors","text":"purposes article, ’ll keep working set profiles apples:","code":"library(cbcTools)  profiles <- cbc_profiles(   price = c(1, 1.5, 2, 2.5, 3),   type = c('Fuji', 'Gala', 'Honeycrisp'),   freshness = c('Poor', 'Average', 'Excellent') )  profiles #> CBC Profiles #> ============ #> price       : Continuous (5 levels, range: 1.00-3.00) #> type        : Categorical (3 levels: Fuji, Gala, Honeycrisp) #> freshness   : Categorical (3 levels: Poor, Average, Excellent) #>  #> Profiles: 45 #> First few rows: #>   profileID price type freshness #> 1         1   1.0 Fuji      Poor #> 2         2   1.5 Fuji      Poor #> 3         3   2.0 Fuji      Poor #> 4         4   2.5 Fuji      Poor #> 5         5   3.0 Fuji      Poor #> 6         6   1.0 Gala      Poor #> ... and 39 more rows"},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"fixed-parameters","dir":"Articles","previous_headings":"Basic Prior Specification","what":"Fixed Parameters","title":"Specifying Priors","text":"Fixed parameters assume know exact coefficient values. Start simplest case:","code":"# Basic fixed priors priors_fixed <- cbc_priors(   profiles = profiles,   price = -0.25, # Negative = prefer lower prices   type = c(0.5, 1.0), # Preferences relative to reference level   freshness = c(0.6, 1.2) # Preferences relative to reference level )  priors_fixed #> CBC Prior Specifications: #>  #> price: #>   Continuous variable #>   Levels: 1, 1.5, 2, 2.5, 3  #>   Fixed parameter #>     Coefficient: -0.25 #>  #> type: #>   Categorical variable #>   Levels: Fuji, Gala, Honeycrisp  #>   Reference level: Fuji #>   Fixed parameter #>     Gala: 0.5 #>     Honeycrisp: 1 #>  #> freshness: #>   Categorical variable #>   Levels: Poor, Average, Excellent  #>   Reference level: Poor #>   Fixed parameter #>     Average: 0.6 #>     Excellent: 1.2"},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"understanding-categorical-variables","dir":"Articles","previous_headings":"Basic Prior Specification > Fixed Parameters","what":"Understanding Categorical Variables","title":"Specifying Priors","text":"categorical attributes, reference level set first level defined cbc_profiles(), case \"Fuji\" Type \"Poor\" Freshness. imply following set priors: Type: Fuji: coefficient = 0 (Reference level) Gala: coefficient = 0.5 (preferred Fuji) Honeycrisp: coefficient = 1.0 (preferred) Freshness: Poor: coefficient = 0 (Reference level) Average: coefficient = 0.6 Excellent: coefficient = 1.2","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"using-named-specifications","dir":"Articles","previous_headings":"Basic Prior Specification > Fixed Parameters","what":"Using Named Specifications","title":"Specifying Priors","text":"can specify levels categorical priors using names: produces set priors priors_fixed example :","code":"priors_named <- cbc_priors(   profiles = profiles,   price = -0.25,   type = c(\"Gala\" = 0.5, \"Honeycrisp\" = 1.0),   freshness = c(\"Average\" = 0.6, \"Excellent\" = 1.2) ) identical(priors_fixed$pars, priors_named$pars) #> [1] TRUE"},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"random-parameters","dir":"Articles","previous_headings":"Basic Prior Specification","what":"Random Parameters","title":"Specifying Priors","text":"Random parameters allow preference heterogeneity across respondents. Use rand_spec() define random parameters. example , use \"n\" specify normal distributions price freshness attributes. Note freshness mean sd vectors since categorical attribute three levels (first level reference level): Three distributions supported: \"n\": normal \"ln\": log-normal (forces positivity) \"cn\": censored normal (forces positivity)","code":"priors_random <- cbc_priors(   profiles = profiles,   price = rand_spec(     dist = \"n\",     mean = -0.25,     sd = 0.1   ),   type = c(0.5, 1.0),   freshness = rand_spec(     dist = \"n\",     mean = c(0.6, 1.2),     sd = c(0.1, 0.1)   ) )  priors_random #> CBC Prior Specifications: #>  #> price: #>   Continuous variable #>   Levels: 1, 1.5, 2, 2.5, 3  #>   Random - Normal distribution #>     Mean: -0.25 #>     SD:   0.1 #>  #> type: #>   Categorical variable #>   Levels: Fuji, Gala, Honeycrisp  #>   Reference level: Fuji #>   Fixed parameter #>     Gala: 0.5 #>     Honeycrisp: 1 #>  #> freshness: #>   Categorical variable #>   Levels: Poor, Average, Excellent  #>   Reference level: Poor #>   Random - Normal distribution #>     Average: #>       Mean: 0.6 #>       SD:   0.1 #>     Excellent: #>       Mean: 1.2 #>       SD:   0.1 #>  #> Correlation Matrix: #>                    price freshnessAverage freshnessExcellent #> price                  1                0                  0 #> freshnessAverage       0                1                  0 #> freshnessExcellent     0                0                  1"},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"parameter-correlations","dir":"Articles","previous_headings":"Basic Prior Specification","what":"Parameter Correlations","title":"Specifying Priors","text":"Model correlations random parameters can included using cor_spec():","code":"priors_correlated <- cbc_priors(   profiles = profiles,   price = rand_spec(     dist = \"n\",     mean = -0.1,     sd = 0.05,     correlations = list(       cor_spec(         with = \"type\",         with_level = \"Honeycrisp\",         value = 0.3       )     )   ),   type = rand_spec(     dist = \"n\",     mean = c(\"Gala\" = 0.1, \"Honeycrisp\" = 0.2),     sd = c(\"Gala\" = 0.05, \"Honeycrisp\" = 0.1)   ),   freshness = c(0.1, 0.2) )  # View the correlation matrix priors_correlated$correlation #>                price typeGala typeHoneycrisp #> price            1.0        0            0.3 #> typeGala         0.0        1            0.0 #> typeHoneycrisp   0.3        0            1.0"},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"types-of-correlations","dir":"Articles","previous_headings":"Basic Prior Specification > Parameter Correlations","what":"Types of Correlations","title":"Specifying Priors","text":"General correlation levels two attributes: Correlation specific level categorical attribute: Correlation specific level another specific level:","code":"cor_spec(   with = \"type\",   value = -0.2 ) cor_spec(   with = \"type\",   with_level = \"Honeycrisp\",   value = 0.3 ) cor_spec(   with = \"freshness\",   level = \"Gala\",   with_level = \"Excellent\",   value = 0.4 )"},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"interaction-effects","dir":"Articles","previous_headings":"Basic Prior Specification","what":"Interaction Effects","title":"Specifying Priors","text":"can include interaction terms priors using int_spec():","code":"# Create priors with interaction effects priors_interactions <- cbc_priors(   profiles = profiles,   price = -0.25,   type = c(\"Fuji\" = 0.5, \"Honeycrisp\" = 1.0),   freshness = c(\"Average\" = 0.6, \"Excellent\" = 1.2),   interactions = list(     # Price sensitivity varies by apple type     int_spec(       between = c(\"price\", \"type\"),       with_level = \"Fuji\",       value = 0.1     ),     int_spec(       between = c(\"price\", \"type\"),       with_level = \"Honeycrisp\",       value = 0.2     ),     # Type preferences vary by freshness     int_spec(       between = c(\"type\", \"freshness\"),       level = \"Honeycrisp\",       with_level = \"Excellent\",       value = 0.3     )   ) )  priors_interactions #> CBC Prior Specifications: #>  #> price: #>   Continuous variable #>   Levels: 1, 1.5, 2, 2.5, 3  #>   Fixed parameter #>     Coefficient: -0.25 #>  #> type: #>   Categorical variable #>   Levels: Fuji, Gala, Honeycrisp  #>   Reference level: Gala #>   Fixed parameter #>     Fuji: 0.5 #>     Honeycrisp: 1 #>  #> freshness: #>   Categorical variable #>   Levels: Poor, Average, Excellent  #>   Reference level: Poor #>   Fixed parameter #>     Average: 0.6 #>     Excellent: 1.2 #>  #> Interactions: #>   price × type[Fuji]: 0.1 #>   price × type[Honeycrisp]: 0.2 #>   type[Honeycrisp] × freshness[Excellent]: 0.3"},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"interaction-types","dir":"Articles","previous_headings":"Basic Prior Specification > Interaction Effects","what":"Interaction Types","title":"Specifying Priors","text":"Continuous × Categorical: Must specify categorical level Categorical × Categorical: Must specify levels: Continuous × Continuous: level specification needed:","code":"int_spec(   between = c(\"price\", \"type\"),   with_level = \"Fuji\",   value = 0.05 ) int_spec(   between = c(\"type\", \"freshness\"),   level = \"Gala\",   with_level = \"Excellent\",   value = 0.1 ) int_spec(   between = c(\"price\", \"weight\"),   value = 0.02 )"},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"no-choice-priors","dir":"Articles","previous_headings":"Basic Prior Specification","what":"No-Choice Priors","title":"Specifying Priors","text":"designs -choice options, specify -choice utility no_choice argument:","code":"# Fixed no-choice prior priors_nochoice_fixed <- cbc_priors(   profiles = profiles,   price = -0.25,   type = c(0.5, 1.0),   freshness = c(0.6, 1.2),   no_choice = -0.5 # Negative values make no-choice less attractive )  # Random no-choice prior priors_nochoice_random <- cbc_priors(   profiles = profiles,   price = -0.25,   type = c(0.5, 1.0),   freshness = c(0.6, 1.2),   no_choice = rand_spec(dist = \"n\", mean = -0.5, sd = 0.2) )  priors_nochoice_fixed #> CBC Prior Specifications: #>  #> price: #>   Continuous variable #>   Levels: 1, 1.5, 2, 2.5, 3  #>   Fixed parameter #>     Coefficient: -0.25 #>  #> type: #>   Categorical variable #>   Levels: Fuji, Gala, Honeycrisp  #>   Reference level: Fuji #>   Fixed parameter #>     Gala: 0.5 #>     Honeycrisp: 1 #>  #> freshness: #>   Categorical variable #>   Levels: Poor, Average, Excellent  #>   Reference level: Poor #>   Fixed parameter #>     Average: 0.6 #>     Excellent: 1.2 #>  #> no_choice: #>   Continuous variable #>   Fixed parameter #>     Coefficient: -0.5"},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"parameter-draws-for-bayesian-analysis","dir":"Articles","previous_headings":"","what":"Parameter Draws for Bayesian Analysis","title":"Specifying Priors","text":"specify random parameters, cbc_priors() automatically generates parameter draws Bayesian D-error calculation. can conrol draw type draw_type argument (\"halton\" \"sobol\") number draws n_draws argument, e.g.:","code":"priors_bayesian <- cbc_priors(   profiles = profiles,   price = rand_spec(     dist = \"n\",     mean = -0.25,     sd = 0.1   ),   type = rand_spec(     dist = \"n\",     mean = c(0.5, 1.0),     sd = c(0.1, 0.2)   ),   freshness = c(0.6, 1.2),   n_draws = 500, # Default = 100   draw_type = \"sobol\" # Default = \"halton\" )  # Inspect the parameter draws price_draws <- priors_bayesian$par_draws[, 1] cat(\"Parameter draws dimensions:\", dim(priors_bayesian$par_draws), \"\\n\") #> Parameter draws dimensions: 500 5 cat(\"Mean of price draws:\", mean(price_draws), \"\\n\") #> Mean of price draws: -0.2496651 cat(\"SD of price draws:\", sd(price_draws), \"\\n\") #> SD of price draws: 0.09856398  # Plot distribution of one parameter hist(   price_draws,   main = \"Distribution of Price Parameter Draws\",   xlab = \"Price Coefficient\" )"},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"mismatched-scales","dir":"Articles","previous_headings":"Common Pitfalls","what":"Mismatched Scales","title":"Specifying Priors","text":"Ensure prior magnitudes match attribute scales:","code":"# Problem: Price in dollars, prior assumes price in cents profiles_dollars <- cbc_profiles(price = c(1.00, 2.00, 3.00), ...) priors_cents <- cbc_priors(profiles_dollars, price = -10, ...) # Too large!  # Solution: Match scales priors_dollars <- cbc_priors(profiles_dollars, price = -0.10, ...) # Appropriate"},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"wrong-reference-levels","dir":"Articles","previous_headings":"Common Pitfalls","what":"Wrong Reference Levels","title":"Specifying Priors","text":"Remember first level always reference:","code":"# If you want \"Excellent\" as reference, reorder profiles profiles_reordered <- cbc_profiles(   price = c(1, 1.5, 2, 2.5, 3),   type = c('Fuji', 'Gala', 'Honeycrisp'),   freshness = c('Excellent', 'Average', 'Poor') # Excellent now reference )  priors_reordered <- cbc_priors(   profiles_reordered,   price = -0.1,   type = c(0.1, 0.2),   freshness = c(-0.1, -0.2) # Negative = worse than excellent )"},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"incompatible-restrictions","dir":"Articles","previous_headings":"Common Pitfalls","what":"Incompatible Restrictions","title":"Specifying Priors","text":"Ensure priors compatible restricted profiles:","code":"# If you've restricted certain profile combinations, # make sure your priors don't assume those combinations are common restricted_profiles <- cbc_restrict(   profiles,   type == \"Fuji\" & price > 2.5 )  # Prior should reflect that expensive Fuji combinations don't exist priors_compatible <- cbc_priors(restricted_profiles, ...)"},{"path":"https://jhelvy.github.io/cbcTools/articles/priors.html","id":"using-priors-in-practice","dir":"Articles","previous_headings":"","what":"Using Priors in Practice","title":"Specifying Priors","text":"created, priors used : Design optimization: Pass cbc_design() D-optimal methods. See Generating Designs article details. Choice simulation: Pass cbc_choices() realistic choice patterns. See Simulating Choices article details.","code":""},{"path":"https://jhelvy.github.io/cbcTools/articles/profiles.html","id":"generating-all-possible-profiles","dir":"Articles","previous_headings":"","what":"Generating all possible profiles","title":"Generating Profiles","text":"first step designing experiment define attributes levels experiment generate profiles possible combination attributes levels. example, let’s say ’re designing conjoint experiment apples want include price, type, freshness attributes. can obtain possible profiles attributes using cbc_profiles() function:","code":"library(cbcTools)  profiles <- cbc_profiles(   price     = seq(1, 5, 0.5), # $ per pound   type      = c('Fuji', 'Gala', 'Honeycrisp'),   freshness = c('Poor', 'Average', 'Excellent') )  profiles #> CBC Profiles #> ============ #> price       : Continuous (9 levels, range: 1.00-5.00) #> type        : Categorical (3 levels: Fuji, Gala, Honeycrisp) #> freshness   : Categorical (3 levels: Poor, Average, Excellent) #>  #> Profiles: 81 #> First few rows: #>   profileID price type freshness #> 1         1   1.0 Fuji      Poor #> 2         2   1.5 Fuji      Poor #> 3         3   2.0 Fuji      Poor #> 4         4   2.5 Fuji      Poor #> 5         5   3.0 Fuji      Poor #> 6         6   3.5 Fuji      Poor #> ... and 75 more rows"},{"path":"https://jhelvy.github.io/cbcTools/articles/profiles.html","id":"restricted-profiles","dir":"Articles","previous_headings":"","what":"Restricted profiles","title":"Generating Profiles","text":"Depending context survey, may wish eliminate profiles designing conjoint survey (e.g., profile combinations may illogical unrealistic). CAUTION: including restrictions designs can substantially reduce statistical power design, use cautiously avoid possible. wish restrict attribute level combinations, can using cbc_restrict() function, takes full set profiles along number restricted pairs attribute levels, defined pairs logical expressions separated commas. example includes following restrictions (arbitrary just illustration purposes): \"Gala\" apples shown prices 1.5, 2.5, 3.5. \"Honeycrisp\" apples shown prices less 2. \"Fuji\" apples shown \"Excellent\" freshness. restrictions, now 57 profiles compared 81 without : profiles, can use generate experiment design cbc_design(). See Generating Designs article details.","code":"restricted_profiles <- cbc_restrict(     profiles,     type == \"Gala\" & price %in% c(1.5, 2.5, 3.5),     type == \"Honeycrisp\" & price < 2,     type == \"Fuji\" & freshness == \"Excellent\" )  dim(restricted_profiles) #> [1] 57  4"},{"path":"https://jhelvy.github.io/cbcTools/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"John Helveston. Maintainer, author, copyright holder.","code":""},{"path":"https://jhelvy.github.io/cbcTools/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Helveston JP (2023). cbcTools: Design Evaluate Choice-Based Conjoint Survey Experiments. R package, https://jhelvy.github.io/cbcTools/.","code":"@Manual{,   title = {{cbcTools}: Design and Evaluate Choice-Based Conjoint Survey Experiments},   author = {John Paul Helveston},   year = {2023},   note = {R package},   url = {https://jhelvy.github.io/cbcTools/}, }"},{"path":"https://jhelvy.github.io/cbcTools/index.html","id":"cbctools-","dir":"","previous_headings":"","what":"Tools For Designing Choice-Based Conjoint Survey Experiments","title":"Tools For Designing Choice-Based Conjoint Survey Experiments","text":"package provides functions generating inspecting survey designs choice-based conjoint survey experiments R. function package begins cbc_ supports step following process designing analyzing survey experiments:  installing package, got Getting Started page learn use package.","code":""},{"path":"https://jhelvy.github.io/cbcTools/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tools For Designing Choice-Based Conjoint Survey Experiments","text":"can install latest version {cbcTools} CRAN: can install development version {cbcTools} GitHub: Load package :","code":"install.packages(\"cbcTools\") # install.packages(\"pak\") pak::pak(\"jhelvy/cbcTools\") library(cbcTools)"},{"path":"https://jhelvy.github.io/cbcTools/index.html","id":"author-version-and-license-information","dir":"","previous_headings":"","what":"Author, Version, and License Information","title":"Tools For Designing Choice-Based Conjoint Survey Experiments","text":"Author: John Paul Helveston https://www.jhelvy.com/ Date First Written: October 23, 2020 License: MIT","code":""},{"path":"https://jhelvy.github.io/cbcTools/index.html","id":"citation-information","dir":"","previous_headings":"","what":"Citation Information","title":"Tools For Designing Choice-Based Conjoint Survey Experiments","text":"use package publication, greatly appreciate cited - can get citation typing citation(\"cbcTools\") R:","code":"citation(\"cbcTools\") #> To cite cbcTools in publications use: #>  #>   Helveston JP (2023). _cbcTools: Design and Evaluate Choice-Based #>   Conjoint Survey Experiments_. R package, #>   <https://jhelvy.github.io/cbcTools/>. #>  #> A BibTeX entry for LaTeX users is #>  #>   @Manual{, #>     title = {{cbcTools}: Design and Evaluate Choice-Based Conjoint Survey Experiments}, #>     author = {John Paul Helveston}, #>     year = {2023}, #>     note = {R package}, #>     url = {https://jhelvy.github.io/cbcTools/}, #>   }"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_choices.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate choices for a survey design — cbc_choices","title":"Simulate choices for a survey design — cbc_choices","text":"Simulate choices survey design, either randomly according utility model defined user-provided prior parameters. priors provided, choices simulated using probability computation framework used cbc_design() consistency.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_choices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate choices for a survey design — cbc_choices","text":"","code":"cbc_choices(design, priors = NULL)"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_choices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate choices for a survey design — cbc_choices","text":"design cbc_design object created cbc_design() priors cbc_priors object created cbc_priors(), NULL (default) random choices.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_choices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate choices for a survey design — cbc_choices","text":"Returns input design additional choice column identifying simulated choices.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_choices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate choices for a survey design — cbc_choices","text":"","code":"library(cbcTools)  # Create profiles and design profiles <- cbc_profiles(   price = c(1, 2, 3),   type = c(\"A\", \"B\", \"C\"),   quality = c(\"Low\", \"High\") )  design <- cbc_design(   profiles = profiles,   n_alts = 2,   n_q = 4 )  # Simulate random choices (default) choices_random <- cbc_choices(design)  # Create priors and simulate utility-based choices priors <- cbc_priors(   profiles = profiles,   price = -0.1,   type = c(0.5, 0.2),  # vs reference level   quality = 0.3 )  choices_utility <- cbc_choices(design, priors = priors)"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_compare.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare multiple choice experiment designs — cbc_compare","title":"Compare multiple choice experiment designs — cbc_compare","text":"function compares multiple CBC designs across key quality metrics including D-error, balance, overlap, structural characteristics. Useful evaluating different design methods parameter settings.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_compare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare multiple choice experiment designs — cbc_compare","text":"","code":"cbc_compare(..., metrics = \"all\", sort_by = \"d_error\", ascending = NULL)"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_compare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare multiple choice experiment designs — cbc_compare","text":"... number cbc_design objects compare, separated commas. Can named clearer output (e.g., random = design1, stochastic = design2). metrics Character vector specifying metrics compare. Options: \"structure\", \"efficiency\", \"balance\", \"overlap\", \"\" (default). Can specify multiple: c(\"efficiency\", \"balance\") sort_by Character. Metric sort designs . Options: \"d_error\" (default), \"balance\", \"overlap\", \"profiles_used\", \"generation_time\", \"none\" ascending Logical. TRUE, sort ascending order (lower better). FALSE, sort descending order (higher better). Default depends metric.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_compare.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare multiple choice experiment designs — cbc_compare","text":"cbc_comparison object containing comparison results, printed formatted table.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_compare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare multiple choice experiment designs — cbc_compare","text":"","code":"library(cbcTools)  # Create profiles profiles <- cbc_profiles(   price = c(1, 2, 3),   type = c(\"A\", \"B\", \"C\"),   quality = c(\"Low\", \"High\") )  # Create different designs design_random <- cbc_design(   profiles = profiles,   method = \"random\",   n_alts = 2, n_q = 4 )  design_stochastic <- cbc_design(   profiles = profiles,   method = \"stochastic\",   n_alts = 2, n_q = 4 ) #> Stochastic design will be optimized into 1 design block, then allocated across 100 respondents #> Running 5 design searches using 3 cores... #>  #> D-error results from all starts: #> Start 2: 1.109400   (Best) #> Start 3: 1.154701  #> Start 4: 1.632993  #> Start 1: 4.000000  #> Start 5: Inf   # Compare designs cbc_compare(design_random, design_stochastic) #> CBC Design Comparison #> ===================== #> Designs compared: 2 #> Metrics: structure, efficiency, balance, overlap #> Sorted by: d_error (ascending) #>  #> Structure #> ===================== #>    Design     Method respondents questions #>  Design 2 stochastic         100         4 #>  Design 1     random         100         4 #>  Alternatives Blocks Profile Usage #>             2      1  (8/18) 44.4% #>             2      1  (18/18) 100% #>  No Choice Labeled? #>         No       No #>         No       No #>  #> Design Metrics #> ===================== #>    Design     Method D-Error (Null) D-Error (Prior) Balance Overlap #>  Design 2 stochastic       1.109400              NA   0.675   0.250 #>  Design 1     random             NA              NA   0.826   0.448 #>  #> Interpretation: #> - D-Error: Lower is better (design efficiency) #> - Balance: Higher is better (level distribution) #> - Overlap: Lower is better (attribute variation) #> - Profile Usage: Higher means more profiles used #>  #> Best performers: #> - Balance: Design 1 (0.826) #> - Overlap: Design 2 (0.250) #> - Profile Usage: Design 1 (100.0%) #>  #> Use summary() for detailed information on any one design.  # Named comparison with specific metrics cbc_compare(   Random = design_random,   Stochastic = design_stochastic,   metrics = c(\"efficiency\", \"balance\"),   sort_by = \"d_error\" ) #> CBC Design Comparison #> ===================== #> Designs compared: 2 #> Metrics: efficiency, balance #> Sorted by: d_error (ascending) #>  #> Design Metrics #> ===================== #>      Design     Method D-Error (Null) D-Error (Prior) Balance #>  Stochastic stochastic       1.109400              NA   0.675 #>      Random     random             NA              NA   0.826 #>  #> Interpretation: #> - D-Error: Lower is better (design efficiency) #> - Balance: Higher is better (level distribution) #>  #> Best performers: #> - Balance: Random (0.826) #>  #> Use summary() for detailed information on any one design."},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_decode.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert dummy-coded CBC data back to categorical format — cbc_decode","title":"Convert dummy-coded CBC data back to categorical format — cbc_decode","text":"function converts dummy-coded CBC designs choice data back original categorical format. useful displaying choice questions respondents analysis requires categorical variables. works data without -choice options, -choice data meaningfully converted back categorical format.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_decode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert dummy-coded CBC data back to categorical format — cbc_decode","text":"","code":"cbc_decode(data)"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_decode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert dummy-coded CBC data back to categorical format — cbc_decode","text":"data cbc_design cbc_choices object dummy-coded categorical variables","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_decode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert dummy-coded CBC data back to categorical format — cbc_decode","text":"input object categorical variables restored original format","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_decode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert dummy-coded CBC data back to categorical format — cbc_decode","text":"","code":"library(cbcTools)  # Create profiles with categorical variables profiles <- cbc_profiles(   price = c(10, 20, 30),   quality = c(\"Low\", \"Medium\", \"High\"),   brand = c(\"A\", \"B\") )  # Create design (will be dummy-coded by default) design <- cbc_design(   profiles = profiles,   n_alts = 2,   n_q = 4 )  # Convert design back to categorical format design_categorical <- cbc_decode(design) head(design_categorical) #> Design method: random #> Structure: 100 respondents × 4 questions × 2 alternatives #> Profile usage: 18/18 (100.0%) #>  #> 💡 Use cbc_inspect() for a more detailed summary #>  #> First few rows of design: #>   profileID respID qID altID obsID price quality brand #> 1         7      1   1     1     1    10    High     A #> 2        11      1   1     2     1    20     Low     B #> 3        11      1   2     1     2    20     Low     B #> 4         1      1   2     2     2    10     Low     A #> 5        10      1   3     1     3    10     Low     B #> 6         5      1   3     2     3    20  Medium     A  # Also works with choice data choices <- cbc_choices(design) choices_categorical <- cbc_decode(choices) head(choices_categorical) #> CBC Choice Data #> =============== #> Observations: 3 choice tasks #> Alternatives per task: 2 #> Total choices made: 3 #>  #> Simulation method: random #> Priors: None (random choices) #> Simulated at: 2025-07-08 11:17:16 #>  #> Choice rates by alternative: #>   Alt 1: 66.7% (2 choices) #>   Alt 2: 33.3% (1 choices) #>  #> First few rows: #>   profileID respID qID altID obsID price choice quality brand #> 1         7      1   1     1     1    10      0    High     A #> 2        11      1   1     2     1    20      1     Low     B #> 3        11      1   2     1     2    20      1     Low     B #> 4         1      1   2     2     2    10      0     Low     A #> 5        10      1   3     1     3    10      1     Low     B #> 6         5      1   3     2     3    20      0  Medium     A"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate survey designs for choice experiments (Updated Implementation) — cbc_design","title":"Generate survey designs for choice experiments (Updated Implementation) — cbc_design","text":"function creates experimental designs choice-based conjoint experiments using multiple design approaches including optimization frequency-based methods.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate survey designs for choice experiments (Updated Implementation) — cbc_design","text":"","code":"cbc_design(   profiles,   method = \"random\",   priors = NULL,   n_alts,   n_q,   n_resp = 100,   n_blocks = 1,   n_cores = NULL,   no_choice = FALSE,   label = NULL,   randomize_questions = TRUE,   randomize_alts = TRUE,   remove_dominant = FALSE,   dominance_types = c(\"total\", \"partial\"),   dominance_threshold = 0.8,   max_dominance_attempts = 50,   max_iter = 50,   n_start = 5 )"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate survey designs for choice experiments (Updated Implementation) — cbc_design","text":"profiles data frame class cbc_profiles created using cbc_profiles() method Choose design method: \"random\", \"stochastic\", \"modfed\", \"cea\", \"shortcut\". Defaults \"random\" priors cbc_priors object created cbc_priors(), NULL random/shortcut designs n_alts Number alternatives per choice question n_q Number questions per respondent (per block) n_resp Number respondents (random/shortcut designs) 1 (optimized designs get repeated) n_blocks Number blocks design. Defaults 1 n_cores Number cores use parallel processing design search. Defaults NULL, case set number available cores minus 1. no_choice Include \"choice\" option? Defaults FALSE label name variable use \"labeled\" design. Defaults NULL randomize_questions Randomize question order respondent? Defaults TRUE (optimized methods ) randomize_alts Randomize alternative order within questions? Defaults TRUE (optimized methods ) remove_dominant Remove choice sets dominant alternatives? Defaults FALSE dominance_types Types dominance check: \"total\" /\"partial\" dominance_threshold Threshold total dominance detection. Defaults 0.8 max_dominance_attempts Maximum attempts replace dominant choice sets. Defaults 50. max_iter Maximum iterations optimized designs. Defaults 50 n_start Number random starts optimized designs. Defaults 5","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate survey designs for choice experiments (Updated Implementation) — cbc_design","text":"cbc_design object containing experimental design","code":""},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_design.html","id":"design-methods","dir":"Reference","previous_headings":"","what":"Design Methods","title":"Generate survey designs for choice experiments (Updated Implementation) — cbc_design","text":"method argument determines design approach used: \"random\": Creates designs randomly sampling profiles respondent independently \"stochastic\": Stochastic profile swapping D-error optimization (first improvement found) \"modfed\": Modified Fedorov algorithm exhaustive profile swapping D-error optimization \"cea\": Coordinate Exchange Algorithm attribute--attribute D-error optimization \"shortcut\": Frequency-based greedy algorithm balances attribute level usage","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_design.html","id":"method-compatibility","dir":"Reference","previous_headings":"","what":"Method Compatibility","title":"Generate survey designs for choice experiments (Updated Implementation) — cbc_design","text":"table summarizes method compatibility design features:","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_design.html","id":"design-quality-assurance","dir":"Reference","previous_headings":"","what":"Design Quality Assurance","title":"Generate survey designs for choice experiments (Updated Implementation) — cbc_design","text":"methods ensure following criteria met: duplicate profiles within choice set duplicate choice sets within respondent remove_dominant = TRUE, choice sets dominant alternatives eliminated (optimization methods )","code":""},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_design.html","id":"random-method","dir":"Reference","previous_headings":"","what":"Random Method","title":"Generate survey designs for choice experiments (Updated Implementation) — cbc_design","text":"Creates designs respondent sees completely independent, randomly generated choice sets.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_design.html","id":"d-error-optimization-methods-stochastic-modfed-cea-","dir":"Reference","previous_headings":"","what":"D-Error Optimization Methods (stochastic, modfed, cea)","title":"Generate survey designs for choice experiments (Updated Implementation) — cbc_design","text":"methods minimize D-error create statistically efficient designs: Stochastic: Random profile sampling first improvement acceptance Modfed: Exhaustive profile testing best improvement (slower thorough) CEA: Coordinate exchange testing attribute levels individually (requires full factorial profiles)","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_design.html","id":"shortcut-method","dir":"Reference","previous_headings":"","what":"Shortcut Method","title":"Generate survey designs for choice experiments (Updated Implementation) — cbc_design","text":"Uses frequency-based greedy algorithm : Tracks attribute level usage within questions across overall design Selects profiles least frequently used attribute levels Provides good level balance without requiring priors D-error calculations Fast execution suitable large designs","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_inspect.html","id":null,"dir":"Reference","previous_headings":"","what":"Comprehensive design quality inspection — cbc_inspect","title":"Comprehensive design quality inspection — cbc_inspect","text":"function provides detailed inspection choice experiment designs across multiple dimensions including design structure, efficiency metrics, attribute balance, overlap patterns, variable encoding.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_inspect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Comprehensive design quality inspection — cbc_inspect","text":"","code":"cbc_inspect(design, sections = \"all\", verbose = FALSE)"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_inspect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Comprehensive design quality inspection — cbc_inspect","text":"design cbc_design object created cbc_design() sections Character vector specifying sections show. Options: \"structure\", \"efficiency\", \"balance\", \"overlap\", \"encoding\", \"\" (default). Can specify multiple: c(\"balance\", \"overlap\") verbose Logical. TRUE, shows additional technical details. FALSE (default), shows simplified output.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_inspect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Comprehensive design quality inspection — cbc_inspect","text":"cbc_inspection object containing inspection results","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_inspect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Comprehensive design quality inspection — cbc_inspect","text":"","code":"library(cbcTools)  # Create profiles and design profiles <- cbc_profiles(   price = c(1, 2, 3),   type = c(\"A\", \"B\", \"C\"),   quality = c(\"Low\", \"High\") )  design <- cbc_design(   profiles = profiles,   n_alts = 2,   n_q = 4 )  # Inspect all sections (default) - prints automatically cbc_inspect(design) #> DESIGN SUMMARY #> ========================= #>  #> STRUCTURE #> ================ #> Method: random #> Created: 2025-07-08 11:17:17 #> Respondents: 100 #> Questions per respondent: 4 #> Alternatives per question: 2 #> Total choice sets: 400 #> Profile usage: 18/18 (100.0%) #>  #> SUMMARY METRICS #> ================= #> D-error calculation not available for random designs #> Overall balance score: 0.812 (higher is better) #> Overall overlap score: 0.461 (lower is better) #>  #> VARIABLE ENCODING #> ================= #> Format: Dummy-coded (type, quality) #> 💡 Use cbc_decode_design() to convert to categorical format #>  #> ATTRIBUTE BALANCE #> ================= #> Overall balance score: 0.812 (higher is better) #>  #> Individual attribute level counts: #>  #> price: #>  #>   1   2   3  #> 264 262 274  #>   Balance score: 0.976 (higher is better) #>  #> typeB: #>  #>   0   1  #> 541 259  #>   Balance score: 0.667 (higher is better) #>  #> typeC: #>  #>   0   1  #> 537 263  #>   Balance score: 0.674 (higher is better) #>  #> qualityHigh: #>  #>   0   1  #> 421 379  #>   Balance score: 0.931 (higher is better) #>  #> ATTRIBUTE OVERLAP #> ================= #> Overall overlap score: 0.461 (lower is better) #>  #> Counts of attribute overlap: #> (# of questions with N unique levels) #>  #> price: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):  28.2%  (113 / 400 questions) #>   2 (partial overlap):   71.8%  (287 / 400 questions) #>   3 (no overlap):         0.0%  (0 / 400 questions) #>   Average unique levels per question: 1.72 #>  #> typeB: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):  55.2%  (221 / 400 questions) #>   2 (no overlap):        44.8%  (179 / 400 questions) #>   Average unique levels per question: 1.45 #>  #> typeC: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):  51.7%  (207 / 400 questions) #>   2 (no overlap):        48.2%  (193 / 400 questions) #>   Average unique levels per question: 1.48 #>  #> qualityHigh: Continuous variable #>   Questions by # unique levels: #>   1 (complete overlap):  49.2%  (197 / 400 questions) #>   2 (no overlap):        50.7%  (203 / 400 questions) #>   Average unique levels per question: 1.51 #>  #>   # Store results for later use inspection <- cbc_inspect(design, sections = \"balance\") inspection  # prints the same output #> DESIGN SUMMARY #> ========================= #>  #> ATTRIBUTE BALANCE #> ================= #> Overall balance score: 0.812 (higher is better) #>  #> Individual attribute level counts: #>  #> price: #>  #>   1   2   3  #> 264 262 274  #>   Balance score: 0.976 (higher is better) #>  #> typeB: #>  #>   0   1  #> 541 259  #>   Balance score: 0.667 (higher is better) #>  #> typeC: #>  #>   0   1  #> 537 263  #>   Balance score: 0.674 (higher is better) #>  #> qualityHigh: #>  #>   0   1  #> 421 379  #>   Balance score: 0.931 (higher is better) #>   # Verbose output with technical details cbc_inspect(design, verbose = TRUE) #> DESIGN SUMMARY #> ========================= #>  #> STRUCTURE #> ================ #> Method: random #> Created: 2025-07-08 11:17:17 #> Generation time: 0.245 seconds #> Respondents: 100 #> Questions per respondent: 4 #> Alternatives per question: 2 #> Total choice sets: 400 #> Profile usage: 18/18 (100.0%) #> Optimization attempts: 3 #>  #> SUMMARY METRICS #> ================= #> D-error calculation not available for random designs #> Overall balance score: 0.812 (higher is better) #> Overall overlap score: 0.461 (lower is better) #>   Profiles used: 18/18 #>  #> VARIABLE ENCODING #> ================= #> Format: Dummy-coded (type, quality) #>  #> Categorical variable details: #>   type: A, B, C (reference: A) #>   quality: Low, High (reference: Low) #> 💡 Use cbc_decode_design() to convert to categorical format #>  #> ATTRIBUTE BALANCE #> ================= #> Overall balance score: 0.812 (higher is better) #>  #> Individual attribute level counts: #>  #> price: #>  #>   1   2   3  #> 264 262 274  #>   Balance score: 0.976 (higher is better), CV: 0.024 (lower is better) #>  #> typeB: #>  #>   0   1  #> 541 259  #>   Balance score: 0.667 (higher is better), CV: 0.499 (lower is better) #>  #> typeC: #>  #>   0   1  #> 537 263  #>   Balance score: 0.674 (higher is better), CV: 0.484 (lower is better) #>  #> qualityHigh: #>  #>   0   1  #> 421 379  #>   Balance score: 0.931 (higher is better), CV: 0.074 (lower is better) #>  #> ATTRIBUTE OVERLAP #> ================= #> Overall overlap score: 0.461 (lower is better) #>  #> Counts of attribute overlap: #> (# of questions with N unique levels) #>  #> price: Continuous variable #>   Unique levels:  1, 2, 3  #>   Questions by # unique levels: #>   1 (complete overlap):  28.2%  (113 / 400 questions) #>   2 (partial overlap):   71.8%  (287 / 400 questions) #>   3 (no overlap):         0.0%  (0 / 400 questions) #>   Average unique levels per question: 1.72 #>  #> typeB: Continuous variable #>   Unique levels:  0, 1  #>   Questions by # unique levels: #>   1 (complete overlap):  55.2%  (221 / 400 questions) #>   2 (no overlap):        44.8%  (179 / 400 questions) #>   Average unique levels per question: 1.45 #>  #> typeC: Continuous variable #>   Unique levels:  0, 1  #>   Questions by # unique levels: #>   1 (complete overlap):  51.7%  (207 / 400 questions) #>   2 (no overlap):        48.2%  (193 / 400 questions) #>   Average unique levels per question: 1.48 #>  #> qualityHigh: Continuous variable #>   Unique levels:  0, 1  #>   Questions by # unique levels: #>   1 (complete overlap):  49.2%  (197 / 400 questions) #>   2 (no overlap):        50.7%  (203 / 400 questions) #>   Average unique levels per question: 1.51 #>  #>"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate power analysis for choice experiment designs — cbc_power","title":"Estimate power analysis for choice experiment designs — cbc_power","text":"function estimates model multiple times using different sample sizes assess statistical power. returns estimated models summary coefficient estimates, standard errors, power statistics.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate power analysis for choice experiment designs — cbc_power","text":"","code":"cbc_power(   data,   outcome = \"choice\",   obsID = \"obsID\",   pars = NULL,   randPars = NULL,   n_breaks = 10,   n_q = NULL,   panelID = NULL,   alpha = 0.05,   return_models = FALSE,   n_cores = NULL,   ... )"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate power analysis for choice experiment designs — cbc_power","text":"data data frame containing choice data. Can cbc_choices object data frame required columns. outcome Name outcome variable column (1 chosen, 0 ). Defaults \"choice\". obsID Name observation ID column. Defaults \"obsID\". pars Names parameters estimate. NULL (default), auto-detect column names cbc_choices objects. randPars Named vector random parameters distributions ('n' normal, 'ln' log-normal). Defaults NULL. n_breaks Number sample size groups test. Defaults 10. n_q Number questions per respondent. Auto-detected cbc_choices objects specified. panelID Name panel ID column panel data. Auto-detected \"respID\" multi-respondent cbc_choices objects. alpha Significance level power calculations. Defaults 0.05. return_models TRUE, includes full model objects returned list. Defaults FALSE. n_cores Number cores parallel processing. Defaults parallel::detectCores() - 1. ... Additional arguments passed logitr::logitr().","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate power analysis for choice experiment designs — cbc_power","text":"cbc_power object containing: power_summary: Data frame sample sizes, coefficients, estimates, standard errors, t-statistics, power models: List estimated models (return_models = TRUE) sample_sizes: Vector sample sizes tested n_breaks: Number breaks used alpha: Significance level used","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_power.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate power analysis for choice experiment designs — cbc_power","text":"","code":"library(cbcTools)  # Create profiles and design profiles <- cbc_profiles(   price = c(1, 2, 3),   type = c(\"A\", \"B\", \"C\"),   quality = c(\"Low\", \"High\") )  design <- cbc_design(profiles, n_alts = 2, n_q = 6)  # Simulate choices priors <- cbc_priors(profiles, price = -0.1, type = c(0.5, 0.2), quality = 0.3) choices <- cbc_choices(design, priors)  # Run power analysis power_results <- cbc_power(choices, n_breaks = 8) #> Auto-detected parameters: price, typeB, typeC, qualityHigh #> Using 'respID' as panelID for panel data estimation. #> Estimating models using 3 cores... #> Model estimation complete!  # View results print(power_results) #> CBC Power Analysis Results #> ========================== #>  #> Sample sizes tested: 12 to 100 (8 breaks) #> Significance level: 0.050 #> Parameters: price, typeB, typeC, qualityHigh #>  #> Power summary (probability of detecting true effect): #>  #> n = 12: #>   price       : Power = 0.051, SE = 0.2087 #>   typeB       : Power = 0.639, SE = 0.4460 #>   typeC       : Power = 0.099, SE = 0.4325 #>   qualityHigh : Power = 0.370, SE = 0.4044 #>  #> n = 38: #>   price       : Power = 0.098, SE = 0.1129 #>   typeB       : Power = 0.958, SE = 0.2453 #>   typeC       : Power = 0.192, SE = 0.2357 #>   qualityHigh : Power = 0.538, SE = 0.1898 #>  #> n = 50: #>   price       : Power = 0.350, SE = 0.1013 #>   typeB       : Power = 0.984, SE = 0.2155 #>   typeC       : Power = 0.215, SE = 0.2003 #>   qualityHigh : Power = 0.683, SE = 0.1693 #>  #> n = 75: #>   price       : Power = 0.133, SE = 0.0819 #>   typeB       : Power = 0.982, SE = 0.1679 #>   typeC       : Power = 0.258, SE = 0.1622 #>   qualityHigh : Power = 0.413, SE = 0.1345 #>  #> n = 100: #>   price       : Power = 0.255, SE = 0.0716 #>   typeB       : Power = 0.994, SE = 0.1472 #>   typeC       : Power = 0.605, SE = 0.1413 #>   qualityHigh : Power = 0.809, SE = 0.1159 #>  #> Use plot() to visualize power curves. #> Use summary() for detailed power analysis. plot(power_results)"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_priors.html","id":null,"dir":"Reference","previous_headings":"","what":"Create prior specifications for CBC models — cbc_priors","title":"Create prior specifications for CBC models — cbc_priors","text":"Creates standardized prior specification object use CBC analysis functions like cbc_choices() cbc_design(). Supports fixed random parameters, flexible specification categorical variable levels interaction terms fixed parameters.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_priors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create prior specifications for CBC models — cbc_priors","text":"","code":"cbc_priors(   profiles,   no_choice = NULL,   n_draws = 100,   draw_type = \"halton\",   interactions = NULL,   ... )"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_priors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create prior specifications for CBC models — cbc_priors","text":"profiles data frame profiles created cbc_profiles() no_choice Prior specification -choice alternative. Can : single numeric value fixed -choice utility rand_spec() object random -choice utility NULL -choice option (default) n_draws Number draws DB-error calculation using Bayesian priors. Defaults 100 draw_type Specify draw type character: \"halton\" (default) \"sobol\" (recommended models 5 random parameters). interactions list interaction specifications created int_spec(). interactions fixed (non-random) parameters supported. interaction must specify appropriate level(s) categorical variables. Defaults NULL (interactions). ... Named arguments specifying priors attribute: fixed parameters: Continuous variables: provide single numeric value Categorical variables: provide either: unnamed vector values one less number levels (dummy coding) named vector mapping levels coefficients (remaining level becomes reference) random parameters: use rand_spec() specify distribution, parameters, correlations","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_priors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create prior specifications for CBC models — cbc_priors","text":"structured prior specification object including parameter draws random coefficients interaction terms. object contains: pars: Vector mean parameter values par_draws: Matrix parameter draws (random parameters specified) correlation: Correlation matrix random parameters (applicable) interactions: List interaction specifications attrs: Detailed attribute information Additional metadata validation compatibility checking","code":""},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_priors.html","id":"fixed-vs-random-parameters","dir":"Reference","previous_headings":"","what":"Fixed vs Random Parameters","title":"Create prior specifications for CBC models — cbc_priors","text":"Fixed parameters assume respondents preference coefficients. Specify simple numeric values. Random parameters assume preference coefficients vary across respondents according specified distribution. Use rand_spec() define distribution type, mean, standard deviation.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_priors.html","id":"categorical-variable-specification","dir":"Reference","previous_headings":"","what":"Categorical Variable Specification","title":"Create prior specifications for CBC models — cbc_priors","text":"categorical variables, can specify priors two ways: Unnamed vector: Provide coefficients levels except first (becomes reference level). Order matters match natural order levels. Named vector: Explicitly map coefficient values specific levels. level specified becomes reference level.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_priors.html","id":"interaction-terms","dir":"Reference","previous_headings":"","what":"Interaction Terms","title":"Create prior specifications for CBC models — cbc_priors","text":"Use interactions parameter int_spec() include interaction effects attributes. interactions fixed parameters supported. categorical variables involved interactions, must specify relevant levels.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_priors.html","id":"no-choice-options","dir":"Reference","previous_headings":"","what":"No-Choice Options","title":"Create prior specifications for CBC models — cbc_priors","text":"including -choice alternative, provide no_choice parameter. can either fixed numeric value rand_spec() random -choice utility.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_priors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create prior specifications for CBC models — cbc_priors","text":"","code":"library(cbcTools)  # Create profiles for examples profiles <- cbc_profiles(   price = c(1, 1.5, 2, 2.5, 3),   type = c('Fuji', 'Gala', 'Honeycrisp'),   freshness = c('Poor', 'Average', 'Excellent') )  # Example 1: Simple fixed priors priors_fixed <- cbc_priors(   profiles = profiles,   price = -0.25, # Negative = prefer lower prices   type = c(0.5, 1.0), # \"Fuji\" is reference level   freshness = c(0.6, 1.2) # \"Poor\" reference level )  # Example 2: Named categorical priors (more explicit) priors_named <- cbc_priors(   profiles = profiles,   price = -0.25,   type = c(\"Gala\" = 0.5, \"Honeycrisp\" = 1.0),  # \"Fuji\" is reference   freshness = c(\"Average\" = 0.6, \"Excellent\" = 1.2)  # \"Poor\" is reference )  # Example 3: Random parameters - normal distributions for \"price\" and \"freshness\" priors_random <- cbc_priors(   profiles = profiles,   price = rand_spec(     dist = \"n\",     mean = -0.25,     sd = 0.1   ),   type = c(0.5, 1.0),   freshness = rand_spec(     dist = \"n\",     mean = c(0.6, 1.2),     sd = c(0.1, 0.1)   ) )  # Example 4: Correlated random parameters priors_correlated <- cbc_priors(   profiles = profiles,   price = rand_spec(     dist = \"n\",     mean = -0.1,     sd = 0.05,     correlations = list(       cor_spec(         with = \"type\",         with_level = \"Honeycrisp\",         value = 0.3       )     )   ),   type = rand_spec(     dist = \"n\",     mean = c(\"Gala\" = 0.1, \"Honeycrisp\" = 0.2),     sd = c(\"Gala\" = 0.05, \"Honeycrisp\" = 0.1)   ),   freshness = c(0.1, 0.2) )  # Example 5: With interaction terms priors_interactions <- cbc_priors(   profiles = profiles,   price = -0.25,   type = c(\"Fuji\" = 0.5, \"Honeycrisp\" = 1.0),   freshness = c(\"Average\" = 0.6, \"Excellent\" = 1.2),   interactions = list(     # Price sensitivity varies by apple type     int_spec(       between = c(\"price\", \"type\"),       with_level = \"Fuji\",       value = 0.1     ),     int_spec(       between = c(\"price\", \"type\"),       with_level = \"Honeycrisp\",       value = 0.2     ),     # Type preferences vary by freshness     int_spec(       between = c(\"type\", \"freshness\"),       level = \"Honeycrisp\",       with_level = \"Excellent\",       value = 0.3     )   ) )  # Example 6: Including no-choice option priors_nochoice_fixed <- cbc_priors(   profiles = profiles,   price = -0.25,   type = c(0.5, 1.0),   freshness = c(0.6, 1.2),   no_choice = -0.5 # Negative values make no-choice less attractive )  # Example 7: Random no-choice priors_nochoice_random <- cbc_priors(   profiles = profiles,   price = -0.25,   type = c(0.5, 1.0),   freshness = c(0.6, 1.2),   no_choice = rand_spec(dist = \"n\", mean = -0.5, sd = 0.2) )  # View the priors priors_fixed #> CBC Prior Specifications: #>  #> price: #>   Continuous variable #>   Levels: 1, 1.5, 2, 2.5, 3  #>   Fixed parameter #>     Coefficient: -0.25 #>  #> type: #>   Categorical variable #>   Levels: Fuji, Gala, Honeycrisp  #>   Reference level: Fuji #>   Fixed parameter #>     Gala: 0.5 #>     Honeycrisp: 1 #>  #> freshness: #>   Categorical variable #>   Levels: Poor, Average, Excellent  #>   Reference level: Poor #>   Fixed parameter #>     Average: 0.6 #>     Excellent: 1.2 #>  priors_random #> CBC Prior Specifications: #>  #> price: #>   Continuous variable #>   Levels: 1, 1.5, 2, 2.5, 3  #>   Random - Normal distribution #>     Mean: -0.25 #>     SD:   0.1 #>  #> type: #>   Categorical variable #>   Levels: Fuji, Gala, Honeycrisp  #>   Reference level: Fuji #>   Fixed parameter #>     Gala: 0.5 #>     Honeycrisp: 1 #>  #> freshness: #>   Categorical variable #>   Levels: Poor, Average, Excellent  #>   Reference level: Poor #>   Random - Normal distribution #>     Average: #>       Mean: 0.6 #>       SD:   0.1 #>     Excellent: #>       Mean: 1.2 #>       SD:   0.1 #>  #> Correlation Matrix: #>                    price freshnessAverage freshnessExcellent #> price                  1                0                  0 #> freshnessAverage       0                1                  0 #> freshnessExcellent     0                0                  1"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_profiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a data frame of all combinations of attribute levels — cbc_profiles","title":"Make a data frame of all combinations of attribute levels — cbc_profiles","text":"function creates data frame possible combinations attribute levels.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_profiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a data frame of all combinations of attribute levels — cbc_profiles","text":"","code":"cbc_profiles(...)"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_profiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a data frame of all combinations of attribute levels — cbc_profiles","text":"... number named vectors defining attribute levels, e.g. price = c(1, 2, 3). Separate vector comma.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_profiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a data frame of all combinations of attribute levels — cbc_profiles","text":"data frame possible combinations attribute levels class cbc_profiles.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_profiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a data frame of all combinations of attribute levels — cbc_profiles","text":"","code":"library(cbcTools)  # Generate all profiles for a simple conjoint experiment about apples profiles <- cbc_profiles(   price     = c(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5),   type      = c(\"Fuji\", \"Gala\", \"Honeycrisp\"),   freshness = c('Poor', 'Average', 'Excellent') )"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_restrict.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain a restricted set of profiles — cbc_restrict","title":"Obtain a restricted set of profiles — cbc_restrict","text":"function returns restricted set profiles data frame.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_restrict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain a restricted set of profiles — cbc_restrict","text":"","code":"cbc_restrict(profiles, ...)"},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_restrict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain a restricted set of profiles — cbc_restrict","text":"profiles data frame class cbc_profiles created using cbc_profiles() function. ... number restricted pairs attribute levels, defined pairs logical expressions separated commas. example, restriction type == 'Fuji' & freshness == 'Poor' eliminate profiles \"Fuji\" type apples never shown \"Poor\" freshness.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_restrict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain a restricted set of profiles — cbc_restrict","text":"restricted set profiles data frame class cbc_profiles.","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cbc_restrict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain a restricted set of profiles — cbc_restrict","text":"","code":"library(cbcTools)  # Generate all profiles for a simple conjoint experiment about apples profiles <- cbc_profiles(   price     = c(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5),   type      = c(\"Fuji\", \"Gala\", \"Honeycrisp\"),   freshness = c('Poor', 'Average', 'Excellent') )  # Obtain a restricted subset of profiles based on pairs of logical # expressions. The example below contains the following restrictions:  # - `\"Gala\"` apples will not be shown with the prices `1.5`, `2.5`, & `3.5`. # - `\"Honeycrisp\"` apples will not be shown with prices less than `2`. # - `\"Honeycrisp\"` apples will not be shown with the `\"Poor\"` freshness. # - `\"Fuji\"` apples will not be shown with the `\"Excellent\"` freshness.  profiles_restricted <- cbc_restrict(     profiles,     type == \"Gala\" & price %in% c(1.5, 2.5, 3.5),     type == \"Honeycrisp\" & price > 2,     type == \"Honeycrisp\" & freshness == \"Poor\",     type == \"Fuji\" & freshness == \"Excellent\" )"},{"path":"https://jhelvy.github.io/cbcTools/reference/cor_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a correlation specification for random parameters — cor_spec","title":"Create a correlation specification for random parameters — cor_spec","text":"Create correlation specification random parameters","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cor_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a correlation specification for random parameters — cor_spec","text":"","code":"cor_spec(with, value, level = NULL, with_level = NULL)"},{"path":"https://jhelvy.github.io/cbcTools/reference/cor_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a correlation specification for random parameters — cor_spec","text":"Character. Name attribute correlate value Numeric. Correlation value -1 1 level Character. categorical variables, specific level correlate with_level Character. categorical variables, specific level correlate ","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/cor_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a correlation specification for random parameters — cor_spec","text":"correlation specification list","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/int_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an interaction specification for fixed parameters — int_spec","title":"Create an interaction specification for fixed parameters — int_spec","text":"Create interaction specification fixed parameters","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/int_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an interaction specification for fixed parameters — int_spec","text":"","code":"int_spec(between, value, level = NULL, with_level = NULL)"},{"path":"https://jhelvy.github.io/cbcTools/reference/int_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an interaction specification for fixed parameters — int_spec","text":"Character vector length 2 specifying two attributes interact value Numeric. Interaction coefficient value level Character. categorical variables, specific level first attribute with_level Character. categorical variables, specific level second attribute","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/int_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an interaction specification for fixed parameters — int_spec","text":"interaction specification list","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/int_spec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an interaction specification for fixed parameters — int_spec","text":"","code":"# Continuous * continuous interaction int_spec(between = c(\"price\", \"weight\"), value = 0.1) #> $attr1 #> [1] \"price\" #>  #> $attr2 #> [1] \"weight\" #>  #> $value #> [1] 0.1 #>  #> $level #> NULL #>  #> $with_level #> NULL #>  #> attr(,\"class\") #> [1] \"cbc_interaction\"  # Continuous * categorical interactions (must specify categorical level) int_spec(between = c(\"price\", \"type\"), with_level = \"Fuji\", value = 0.15) #> $attr1 #> [1] \"price\" #>  #> $attr2 #> [1] \"type\" #>  #> $value #> [1] 0.15 #>  #> $level #> NULL #>  #> $with_level #> [1] \"Fuji\" #>  #> attr(,\"class\") #> [1] \"cbc_interaction\" int_spec(between = c(\"price\", \"type\"), with_level = \"Gala\", value = 0.05) #> $attr1 #> [1] \"price\" #>  #> $attr2 #> [1] \"type\" #>  #> $value #> [1] 0.05 #>  #> $level #> NULL #>  #> $with_level #> [1] \"Gala\" #>  #> attr(,\"class\") #> [1] \"cbc_interaction\"  # Categorical * categorical interactions (must specify both levels) int_spec(between = c(\"type\", \"freshness\"),          level = \"Fuji\", with_level = \"Poor\", value = -0.2) #> $attr1 #> [1] \"type\" #>  #> $attr2 #> [1] \"freshness\" #>  #> $value #> [1] -0.2 #>  #> $level #> [1] \"Fuji\" #>  #> $with_level #> [1] \"Poor\" #>  #> attr(,\"class\") #> [1] \"cbc_interaction\""},{"path":"https://jhelvy.github.io/cbcTools/reference/plot.cbc_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for cbc_power objects — plot.cbc_power","title":"Plot method for cbc_power objects — plot.cbc_power","text":"Plot method cbc_power objects","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/plot.cbc_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for cbc_power objects — plot.cbc_power","text":"","code":"# S3 method for class 'cbc_power' plot(x, type = \"power\", power_threshold = 0.8, ...)"},{"path":"https://jhelvy.github.io/cbcTools/reference/plot.cbc_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for cbc_power objects — plot.cbc_power","text":"x cbc_power object type Type plot: \"power\" power curves \"se\" standard error curves power_threshold Power threshold horizontal reference line (power plots). Defaults 0.8 ... Additional arguments passed ggplot","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/plot_compare_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare power across multiple designs — plot_compare_power","title":"Compare power across multiple designs — plot_compare_power","text":"Compare power across multiple designs","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/plot_compare_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare power across multiple designs — plot_compare_power","text":"","code":"plot_compare_power(..., type = \"power\", power_threshold = 0.8)"},{"path":"https://jhelvy.github.io/cbcTools/reference/plot_compare_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare power across multiple designs — plot_compare_power","text":"... Named cbc_power objects compare type Type plot: \"power\" power curves \"se\" standard error curves power_threshold Power threshold horizontal reference line (power plots). Defaults 0.8","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/plot_compare_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare power across multiple designs — plot_compare_power","text":"ggplot object comparing power curves","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_choices.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for cbc_choices objects — print.cbc_choices","title":"Print method for cbc_choices objects — print.cbc_choices","text":"Print method cbc_choices objects","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_choices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for cbc_choices objects — print.cbc_choices","text":"","code":"# S3 method for class 'cbc_choices' print(x, ...)"},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_choices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for cbc_choices objects — print.cbc_choices","text":"x cbc_choices object ... Additional arguments passed print","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_comparison.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for cbc_comparison objects — print.cbc_comparison","title":"Print method for cbc_comparison objects — print.cbc_comparison","text":"Print method cbc_comparison objects","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_comparison.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for cbc_comparison objects — print.cbc_comparison","text":"","code":"# S3 method for class 'cbc_comparison' print(x, ...)"},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_comparison.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for cbc_comparison objects — print.cbc_comparison","text":"x cbc_comparison object ... Additional arguments passed print","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Concise print method for cbc_design objects — print.cbc_design","title":"Concise print method for cbc_design objects — print.cbc_design","text":"Concise print method cbc_design objects","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Concise print method for cbc_design objects — print.cbc_design","text":"","code":"# S3 method for class 'cbc_design' print(x, ...)"},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Concise print method for cbc_design objects — print.cbc_design","text":"x cbc_design object ... Additional arguments passed print","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_inspection.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for cbc_inspection objects — print.cbc_inspection","title":"Print method for cbc_inspection objects — print.cbc_inspection","text":"Print method cbc_inspection objects","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_inspection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for cbc_inspection objects — print.cbc_inspection","text":"","code":"# S3 method for class 'cbc_inspection' print(x, ...)"},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_inspection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for cbc_inspection objects — print.cbc_inspection","text":"x cbc_inspection object ... Additional arguments passed print","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for cbc_power objects — print.cbc_power","title":"Print method for cbc_power objects — print.cbc_power","text":"Print method cbc_power objects","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for cbc_power objects — print.cbc_power","text":"","code":"# S3 method for class 'cbc_power' print(x, ...)"},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for cbc_power objects — print.cbc_power","text":"x cbc_power object ... Additional arguments passed print","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_priors.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for cbc_priors objects — print.cbc_priors","title":"Print method for cbc_priors objects — print.cbc_priors","text":"Print method cbc_priors objects","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_priors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for cbc_priors objects — print.cbc_priors","text":"","code":"# S3 method for class 'cbc_priors' print(x, ...)"},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_priors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for cbc_priors objects — print.cbc_priors","text":"x cbc_priors object ... Additional arguments passed print","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_profiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for cbc_profiles objects — print.cbc_profiles","title":"Print method for cbc_profiles objects — print.cbc_profiles","text":"Print method cbc_profiles objects","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_profiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for cbc_profiles objects — print.cbc_profiles","text":"","code":"# S3 method for class 'cbc_profiles' print(x, ...)"},{"path":"https://jhelvy.github.io/cbcTools/reference/print.cbc_profiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for cbc_profiles objects — print.cbc_profiles","text":"x cbc_profiles object ... Additional arguments passed print","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/rand_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a random parameter specification — rand_spec","title":"Create a random parameter specification — rand_spec","text":"Create random parameter specification","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/rand_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a random parameter specification — rand_spec","text":"","code":"rand_spec(dist = \"n\", mean, sd, correlations = NULL)"},{"path":"https://jhelvy.github.io/cbcTools/reference/rand_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a random parameter specification — rand_spec","text":"dist Character. Distribution type: \"n\" normal, \"ln\" log-normal, \"cn\" censored normal mean Numeric. Mean parameter value(s) sd Numeric. Standard deviation parameter value(s) correlations List correlation specifications created cor_spec()","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/rand_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a random parameter specification — rand_spec","text":"random parameter specification list","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/summary.cbc_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for cbc_power objects — summary.cbc_power","title":"Summary method for cbc_power objects — summary.cbc_power","text":"Summary method cbc_power objects","code":""},{"path":"https://jhelvy.github.io/cbcTools/reference/summary.cbc_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for cbc_power objects — summary.cbc_power","text":"","code":"# S3 method for class 'cbc_power' summary(object, power_threshold = 0.8, ...)"},{"path":"https://jhelvy.github.io/cbcTools/reference/summary.cbc_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for cbc_power objects — summary.cbc_power","text":"object cbc_power object power_threshold Minimum power threshold report sample size requirements ... Additional arguments","code":""},{"path":[]},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-060","dir":"Changelog","previous_headings":"","what":"cbcTools 0.6.0","title":"cbcTools 0.6.0","text":"Major overhaul package breaking changes. New function, `cbc_priors()``. allows users specify set priors according wide variety model specifications, including random parameters (without correlated heterogeneity), interactions, “choice” options. priors can used create designs simulate choices. Coefficients levels attribute cbc_priors() can named vectors, addressing #24. One “random”, three frequency-based (“greedy”) algorithms, three d-error minimizing algorithms. Old methods removed: \"full\", \"orthogonal\", \"dopt\", \"CEA\", \"Modfed\" Bayesian D-efficient designs now created based priors provided. random parameters priors, Bayesian D-efficient design created. New support removing dominant alternatives designs. New support randomizing order questions alternatives across respondents, addresses #29. New cbc_inspect() function comprehensively inspecting designs. New cbc_compare() function comparing designs. New functionality cbc_power() computing visualizing power analyses.","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-052","dir":"Changelog","previous_headings":"","what":"cbcTools 0.5.2","title":"cbcTools 0.5.2","text":"Bug fix checking input settings (#34)","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-051","dir":"Changelog","previous_headings":"","what":"cbcTools 0.5.1","title":"cbcTools 0.5.1","text":"Patch fix joining issue join_profiles() function (#27)","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-050","dir":"Changelog","previous_headings":"","what":"cbcTools 0.5.0","title":"cbcTools 0.5.0","text":"CRAN release: 2023-07-12 revisions method argument cbc_design() function. Added \"random\" \"dopt\" methods. Added restrictions orthogonal designs use label argument restricted profile sets (either result non-orthogonal design).","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-040","dir":"Changelog","previous_headings":"","what":"cbcTools 0.4.0","title":"cbcTools 0.4.0","text":"CRAN release: 2023-06-30 Adjustments made method argument cbc_design() function preparation potentially adding new design methods. Added \"orthogonal\" option generating orthogonal designs.","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-034","dir":"Changelog","previous_headings":"","what":"cbcTools 0.3.4","title":"cbcTools 0.3.4","text":"CRAN release: 2023-06-13 Another small bug fix cbc_design() related #16 factor level ordering categorical variables mis-ordered. Updated method argument handled default cbc_design() flexible (anticipating methods future). Added keep_db_error arg cbc_design().","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-033","dir":"Changelog","previous_headings":"","what":"cbcTools 0.3.3","title":"cbcTools 0.3.3","text":"CRAN release: 2023-06-02 Bug fix cbc_design() factor level ordering categorical variables mis-ordered. Added additional input check appropriate priors cbc_design().","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-032","dir":"Changelog","previous_headings":"","what":"cbcTools 0.3.2","title":"cbcTools 0.3.2","text":"CRAN release: 2023-05-23 Modify restrictions defined cbc_restrict() function allow users provide expressions.","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-031","dir":"Changelog","previous_headings":"","what":"cbcTools 0.3.1","title":"cbcTools 0.3.1","text":"Add cbc_restrict() function improve UI adding restrictions profiles. Remove previous approach including restrictions cbc_profiles(). Add new test cases","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-030","dir":"Changelog","previous_headings":"","what":"cbcTools 0.3.0","title":"cbcTools 0.3.0","text":"CRAN release: 2023-05-09 Bug fix: modify code cbc_design() avoid duplicate choice sets respondents; addresses #7. Bug fix: modify code cbc_design() allow Bayesian D-efficient designs restricted profile sets; addresses #10 #9.","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-020","dir":"Changelog","previous_headings":"","what":"cbcTools 0.2.0","title":"cbcTools 0.2.0","text":"CRAN release: 2023-02-28 Added startup message package loaded. Updates compatibility logitr version 1.0.1. Updated DESCRIPTION CITATION remove redundancy title. Updated documentation returned values several functions.","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-010","dir":"Changelog","previous_headings":"","what":"cbcTools 0.1.0","title":"cbcTools 0.1.0","text":"Added initial integration {idefix} packages Bayesian D-efficient designs","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-005","dir":"Changelog","previous_headings":"","what":"cbcTools 0.0.5","title":"cbcTools 0.0.5","text":"Updates compatibility logitr version 0.8.0.","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-004","dir":"Changelog","previous_headings":"","what":"cbcTools 0.0.4","title":"cbcTools 0.0.4","text":"Updates compatibility logitr version 0.7.0.","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-003","dir":"Changelog","previous_headings":"","what":"cbcTools 0.0.3","title":"cbcTools 0.0.3","text":"Modified argument cbc_profiles() ... user longer needs create separate list define attributes levels. Modified arguments randN() randLN() functions mean sd. Improved printing counts cbc_balance() cbc_overlap(). Updated names random parameter models match future logitr v0.6.0. Updated documentation examples functions. Adding piping example readme.","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-002","dir":"Changelog","previous_headings":"","what":"cbcTools 0.0.2","title":"cbcTools 0.0.2","text":"Added support conditional levels cbc_profiles()","code":""},{"path":"https://jhelvy.github.io/cbcTools/news/index.html","id":"cbctools-001","dir":"Changelog","previous_headings":"","what":"cbcTools 0.0.1","title":"cbcTools 0.0.1","text":"Added NEWS.md file track changes package.","code":""}]
